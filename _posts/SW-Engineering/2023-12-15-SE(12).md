---
title: '소프트웨어 공학(12)'
layout: post
categories:
  - SW-Engineering
comments: true
permalink: categories/SW-Engineering
---

## 요구 공학(Requirement Engineering)

**정의**

고객이 시스템에 요구하는 서비스가 무엇인지 확립하고 시스템을 개발하고 운영하는 동안 충족해야하는 제약사항이 무엇인가를 정립하는 과정

실질적인 개발 과정에서 가장 먼저 진행되는 작업.<br>
이 작업의 결과를 바탕으로 이후의 설계(design), 구현(implementation), 테스트(test)가 진행<br>

시스템에 대한 요구사항을 완전하게(complete), 그리고 요구사항 간의 충돌이 없도록 일관성 있게(consistent) 정립하는 것을 추구한다.

**Requirement Engineering Tasks**

⭐️ 소프트웨어 개발에 아주 중요한 과정<br>
(1) Elicitation (추출) <br>
(2) Elaboration (정제)<br>
(3) Negotiation (조정)<br>
(4) Specification (정의)<br>
(5) Validation (검증)<br>
(6) Requirements management(관리) : 변화 관리<br>

**Elicitation (추출)**

💡 소프트웨어가 해결해야 할 문제를 이해하고, 고객으로 부터 제시되는 추상적 요구에 대해 관련 정보를 식별하고 수집 방법 결정, 수집된 요구사항을 구체적으로 표현하는 단계

- 고객 분석, 조직환경 분석, 후보 요구사항 분류, 후보 요구사항 정제, 요구사항 소스 관리
- 주요 기법 : 인터뷰, 브레인 스토밍, 델파이 기법, 롤플레잉, 워크숍, 설문조사

**Elaboration (정제)**

💡 모델링 작업 분석, 상세 기간 동안 고객의 정보는 확장, 재정의 되는 단계

<br>

<img src = "/Users/haeju/Desktop/had2-you.github.io/assets/img/Elaboration.png">

(1) Scenario-based Models<br>
(2) Class-based Models<br>
(3) Behavioral Models<br>
(4) Flow-oriented Models<br>
(5) Data Models<br>

**Negotiation (조정)**

요구사항의 우선순위를 정하고, 요구사항에 따른 비용과 시간을 종합분석해서 중재<br>
서로다른 customer들의 요구가 충돌할 수 있다. → **reconcile**<br>
key는 <u>stakeholder</u><br>

**Specification (정의)**

💡 명세는 서류로, 그래픽 모델로, 기하학적 모델로, 시나리오로, 프로토타입(시제품)이나 이들을 결합한 형태

- Standard template 표준화된 템플릿
- 일관성있어야하고, 이해가능해야한다

**Validation (검증)**

- 품질에 관한 것

- 검증하고 명세(<u>소프트웨어의 요구를 확실</u>하게 하기 위해)

  - 상태가 애매모호함이 없는가?
  - 비일관성
  - 생략과 에러가 감지되고 수집되지 않았는가?
  - 작업 산출물이 프로젝트의 기준을 지키는가?

    <br>

  **_validation을 위한 질문들_**<br>
  ✅ 오브젝트의 요구사항이 일관적인가?<br>
  ✅ 모든 요구사항이 추상화 수준을 사용하여 지정되어있는가?<br>
  ✅ 요구사항이 정말 필요한가?<br>
  ✅ 요구사항에 속성이 있는가?<br>
  ✅ 다른 요구사항과 요구사항끼리의 충돌이 있는가?<br>
  ✅ 각각의 요구사항 한번 시행되서 테스트해볼 수 있는가?<br>
  ✅ 요구사항 모델이 적절히 정보를 반영하고 기능, 함수,시스템의 행동을 잘 반영되었는가?<br>
  ✅ 요구사항이 분할되었는가?<br>
  ✅ 요구사항 패턴이 사용되었는가?<br>

**Stakeholder?**

💡 개발 시스템(개발부터 사용까지)에 관련된 사람들의 집합<br>
기술 스텝, 사용자, 매니저, 공학자, 도메인 전문가, 협회 사람들(그 시스템에서 사용되는 데이터 포맷을 주관하는 사람)이 참가한다.

👿 문제점 <br>
자신들이 실제로 원하는 것이 무엇인지를 모름<br>
그들만의 언어로 요구사항을 이야기 함<br>
서로 충돌을 하거나 문제가 발생할 수 있음<br>

<br>

## 소프트웨어 디자인(Software Design)

💡 원칙을 세우고, 개념을 설정하고 이걸 실행하는 디자인

- 이런 소프트웨어 디자인은 최고 품질의 시스템과 제품을 생산할 수 있어야 한다.
- 디자인 컨셉은 디자인대로 생산을 하기전에 무조건적으로 이해가 되어있어야 한다.
- 소프트웨어 디자인을 실행하는 기술이나 기법은 언제든지 바뀔 수 있다. 새로운 기술이나 분석기술, 소프트웨어에 대한 새로운 이해가 이뤄졌을 때 바뀐다.

<img src = "/Users/haeju/Desktop/had2-you.github.io/assets/img/designmodel.png">

- 시대가 객체지향을 추구함에 따라, 실질적인 디자인 모델을 생성할 때는 Analysis Model의 Class-Based Elements가 가장 큰 영향을 미친다.
- Behavioral Elements <br>

Activity diagrams는 사건의 순서대로 그리게 되는데, 이때 사용되는 컴포넌트들을 그룹화하게 되어 Component-Level Design에 영향을 미친다.
각 컴포넌트를 그릴 때 State Diagram을 그리게 된다.

**Detailed Design**

각 모듈내의 알고리즘 수준으로 내용을 설계함<br>
일반적으로 잘 안하는 경향이 있음<br>
모든 모듈이 아니더라도 중요 모듈은 작성 후 검증이 필요함<br>

**UI Design**

💡 일반적으로 시스템이 얼마나 사용하기 편한지 나타내는 척도<br>
사용자가 어떤 사용 환경에서 특정 목표를 달성하기 위해 소프트웨어 제품이 효과적 및 효율적으로 만족하게 사용할 수 있는 정도<br>
인간과 컴퓨터의 상호작용을 개선하기 위한 방법, 기술을 포함한 사용의 용이성에 대한 연구를 설명하는 용어<br>

<u>설계 원칙</u><br>
(1) 직관성<br>
(2) 유효성 : 정확하고 완벽하게 사용자의 목표 달성될 수 있어야 함 → 쉬운 오류 처리 및 복구<br>
(3) 학습성 : 모두가 쉽게 배우고 사용할 수 있도록 해야 함<br>
(4) 유연성 : 사용자의 인터랙션 최대한 포용 및 실수 방지할 수 있도록 해야 함<br>

## 결합도 & 응집도

**결합도**

💡 서로 다른 모듈 간 상호 의존하는 정도 또는 두 모듈 사이의 연관된 관계

|   구분   |                                                                                                                      설명                                                                                                                       |
| :------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
|   Data   |                                                                - 모듈 간의 인터페이스로 전달되는 파라미터를 통해서만 모듈 간의 상호작용이 일어나는 경우<br> - 순수한 자료형 요소                                                                |
|  Stamp   |                    - 모듈 간의 인터페이스로 배열이나 오브젝트, 스트럭처 등이 전달되는 경우 <br>- 자료 구조의 형태 변경 시 참조하고 있는 모든 모듈에 영향 미침 <br>- 변경되는 필드를 실제로 참조하지 않는 모듈에도 영향 미침                     |
| Control  |                                                                      - 단순 처리할 대상인 값만 전달되는 게 아니라 어떻게 처리를 해야 한다는 제어 요소가 전달되는 경우<br>                                                                       |
| External | - 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성들이 그 기능을 순차적으로 수행할 경우<br>- 특수한 외부환경에 종속 또는 연관되어있는 경우 <br> ex) 외부의 데이터, 통신 프로토콜 등을 공유할 때 <br>- 참조되는 데이터의 범위가 각 모듈에서 제한 |
|  Common  |                                                                      - 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 갱신하는 식으로 상호작용하는 경우<br>                                                                       |
| Content  |                                                                                      - 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우<br>                                                                                      |

**응집도**

💡 모듈 내부에서 구성 요소 간에 밀접한 관계를 맺고 있는 정도

|     구분      |                                              설명                                               |
| :-----------: | :---------------------------------------------------------------------------------------------: |
|  Functional   |                   - 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우                    |
|  Sequential   |               - 모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동에 사용할 경우               |
| Communication |        - 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여 있는 경우<br>         |
|  Procedural   | - 모듈이 다수의 관련 기능을 가질 때, 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행하는 경우 |
|   Temporal    |  - 연관된 기능이라기보다는 특정 시점에 처리되어야 하는 활동들을 한 모듈에서 처리하는 경우<br>   |
|    Logical    |     - 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우<br>     |
| Coincidental  |                         - 모듈 내부의 각 구성 요소들이 연관이 없는 경우                         |
