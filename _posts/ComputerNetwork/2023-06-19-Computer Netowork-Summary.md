---
title: 'Summary'
layout: post
categories:
  - ComputerNetwork
tags:
  - cs
comments: true
---

<details>
<summary>3주차 내용정리</summary>
<div markdown="1">       

<br>

**분산시스템**
```
🔎 어떤 일을 하나에서 전부 처리하지 않고 분산하여 처리
sysytem? 어떠한 동일한 목적을 이루기위해 여러 개의 구성요소들이 서로 협력하여 해당 일을 효율적으로 처리하는 것
```


### s/w system?
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/985ca25e-779e-472f-9374-d351521b6bbc)
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/f1a7bcf1-9dfc-4531-8d61-ed594b1fae9e)

> P 부분을 client, A와 D를 Server로 나누지만, A와 D를 한번 더 나눌 수도 있음
> 
> 클라이언트 파트는 사용자에게 보여지는 것 뿐만 아니라 처리하는 부분으로 한 번 더 나눌 수 있음(서버의 부담을 줄여줌)
> 
> 사용자 입장에서 컴퓨터 내부에서는 나누어져 있지만 사용자가 의식하면 안됨

<br>

**DNS?**
```
🔎 떨어져 있는 컴퓨터의 ip를 찾아가기 위해 도메인주소와 ip주소를 매칭시켜주는 역할
   → 'www.google.com'이라는 주소를 사용자는 검색했지만 컴퓨터 입장에서는 ip주소를 찾아가야하기 때문
```

찾아가기 위해서는 내 컴퓨터의 ip가 필요, 가정에서의 경우 하나의 고정된 ip를 사용하지만 학교와 같은 경우 필요할 때마다 할당을 해주어야함. → DHCP
어플리케이션 프로그램을 개발하는 입장에서는 라우터와 같은 네트워크 코어 디바이스를 신경쓸 필요가 없음 → 어플리케이션 부분은 운영체제가 담당

<br>

### 분산시스템을 구조화시키는 두가지
1. c/s(client & server) : 클라이언트는 요청, 서버는 응답, cs는 역할이 고정적 서버는 항상 대기를 하고 있어야 함(고정아이피를 가지고 있어야함) 데이터도 많고 집중되기 때문에 데이터 센터에서 운영(최근들어 데이터센터를 운영하는 것이 중요)
→ 운영비 등 비용 소요
→ 각각의 회사가 데이터 센터를 운영하는 것 보다는 서버를 운영하고 도와주는 클라우드 컴퓨터를 이용 클라이언트는 요청만 하기 때문에 고정아이피를 사용할 필요가 없음(동적 아이피)
2. p2p : 좀 더 발달된 형태

```
⭐️ 클라우드 컴퓨팅 ? 많은 컴퓨터가 뭉쳐져 있는 형태 (크게 3가지 종류 나눔)

1. IaaS : 네이버나 구글과 같이 기본적인 메모리 할당해주는 것
2. PaaS : 내 컴퓨터에서 개발하기 위해 프로그램 설치 등 환경을 클라우드가 제공
3. SaaS : 만들어진 것을 이용만 하는 것
```

### P2P architecture

만약 1만명이 이용할 수 있는 서버가 갑자기 10만명이 이용해야한다면 하드웨어 교체 등 비용이 들어가게 됨
→ p2p는 확장성이 좋음(내가 클라이언트도 될 수 있고 서버가 될 수도 있기 때문)

**프로세스와 스레드의 차이**
프로세스? 하드에 있던 어떤 프로그램이 cpu에 올라가서 실행되어지는 상태
쓰레드? 프로세스와 같은 개념이지만 경량화 되어 있음
한 컴퓨터 안에도 클라이언트와 서버가 공존할 수 있음

<br>


![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/84bba63c-c9a6-43cb-8def-ad88b8f03f20)

**소켓**
```
만약 한 컴퓨터 안에 있는 서버와 클라이언트가 소통을 할 때 메세지의 부분까지 설계를 하려고 한다면 번거롭기 때문에 이를 돕는 역할, 운영체제가 제공
서버와 클라이언트에 따라 소켓의 함수차이, 구조가 다름
```

1. bind : 서버는 고정아이피를 가지기 때문에 바인딩하는 함수 사용
2. connect : 클라이언트가 서버에게 커넥트 요청을 보내는 것
3. accept : 수락할 때까지 반복문
4. send/recv : 데이터 주고받는 것

<br>

ip주소 : 32비트, 4자리수 숫자

한 컴퓨터(=주소가 동일하다는 의미) 안에 여러개의 프로세스가 돌아가면 어떻게 주소를 찾나? port number(=process number)를 통해 원하는 곳에 접근 가능
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/3983e7bc-f3bd-4d63-b2c5-07a160214fab)

sequence number : 패킷을 하나만 보내는 것이 아니기때문에 패킷에 순서를 부여
Acknowledge number : 보낸 후 반대쪽에서 응답이 있은 후 다시 보낼 때 받았다는 메세지를 보내는 것
checksum : 에러 유무
요청을 받는 쪽인지 보내는 쪽인지가 맨 앞에 기재됨
신택스에는 정보가 어느 자리에 들어가야 하는지 자리까지 정해져 있음

<br>

**⭐️ syntax vs semantics**
```
프로토콜 안에는 메세지에 syntax, semantics 가 있음
전자 규칙, 문법 후자는 의미
ex) a=b → 자체는 규칙(syntax)이 됨

cs 적 관점 : b를 a에 대입
수학적 관점 : a와 b는 같다
→ 두가지의 의미(semantics)를 가짐
```

data integrity : 파일의 경우 신뢰성이 중요 (no loss)/ 오디오, 비디오와 같은 것들은 손실을 어느정도 반영할 수 있음
timing : 음성의 경우 시간이 중요
throughput : 링크가 가진 대역폭 = R , 패킷의 길이 = L 일 때, L/R = 전송률, 고정적이지 않음, 어느정도의 전송률이 보장되어야 하는가 아닌가? 데이터는 괜찮지만 동영상의 경우 중요함
security : 보안성

### TCP 특징
```
1. 신뢰성있는 전송을 보장, 따라서 보내는 쪽이 안심하고 보내고 받을 수 있음
2.  flow control vs congestion control : A를 클라이언트, B를 서버라고 할 때 B가 데이터를 받은 후 큐(자신의상태)의 상태를 A쪽으로 보낸다.(A가 많은 양의 정보를 보내려고 할 때 라던지..)
                                         → 이렇게 하면 A는 속도를 조절하여 보낸다. → 서버의 문제 congestion 은 통신망 문제
4.  시간, 전송률과 같은 것을 보장하지 못함 (위와 같은 문제에 시간이 들기 때문)
5.  보내기 전에 연결이 확실하게 되었는지 확인(hand-shake)
```
↔ 반대되는 것이 UDP 특징

기본적으로 인터넷은 보안에 취약하기 때문에 다른 프로토콜(SSL)의 도움을 받아야함

**3장**

Web? 거미줄.. 인터넷과 다른 의미, 문서가 연결된 것 hypertext(link) 링크를 타고타고 연결되어 얽히고 웹문서들. 웹페이지는 여러 개의 문서로 연결되어 있다.

웹페이지는 오브젝트(html file, 사진, 오디오 파일 등을 일컫는다)

각각의 위치를 나타낸 것을 URL(오브젝트 들의 주소)이라고 함

### url, urn 차이
```
url은 프로토콜(http://) 포함 urn은 프로토콜 제외, 페이지, 확장자 등을 포함
url + urn = uri
```
sgml → html → xml
xml? 태그<>를 통해 글자의 의미를 부여하고자 함

http를 통해 웹이 어떻게 주고 받는가?

브라우저라는 것을 통해 접근하고 주고받을 때에는 http 전부 프로토콜을 사용

http 하단에는 tcp 프로토콜의 도움을 받음


![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/759dea7d-915c-4ada-804c-db5488be0c07)


클라이언트와 서버가 **3-way handshake**를 함

비상태연결(Stateless)? 클라이언트가 서버에게 한 요청(상태)를 서버가 저장하지 않는 것을 의미
포트번호 = 프로세스번호 한 포트번호에 여러 개의 프로세스가 돌아감
포트번호 배정 누가? 프로세스 누가 관리? → OS

비상태연결 : 기본적으로 상태를 저장하지 않지만 저장하는 방법이 있음 → cookie(쿠키)


### 쿠키? 
```
서버에 들어온 어떤 사람에게 번호를 부여 → 쿠키가 됨
해당 쿠키를 데이터베이스에 저장하고 어떤 아이피를 통해 들어왔는지, 어떤 물건을 구매했는지 등을 저장
서버에서 응답 시 응답메세지에 쿠키번호를 숨겨서 같이 보내줌 하지만 클라이언트는 모름
이후 클라이언트가 페이지를 옮겨 다른 페이지를 볼 때마다 서버에 저장
일주일 후에 들어가도 쿠키가 남아있음
→ CRM 으로 이용..

왜 쿠키 사용? 기본적으로 웹이 비상태이기 때문에 단점을 보완하기 위해
```

### 비지속성(non-persistent)?
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/bfb7e92f-5f83-4cc2-bc4b-35bfe9130a74)

웹페이지의 오브젝트(자원)들이 하나하나 연결과 종료를 반복하며 요청에 대한 응답을 반복 → 시간과 서버자원 낭비

http 1.0 에서 사용

소켓 하나당 오브젝트 한 개 but, 소켓 여러개가 동시에 열릴 수 는 있음

### 지속성(persistent)?

![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/44061b10-abfd-49b1-b816-b18cbaa7e826)
여러 개의 요청, 응답을 서버, 클라이언트간 연결을 유지하면서 처리하는 방식

하나의 소켓으로 전부 연결하며 보내는 것
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/2d766cd5-6f15-4f74-bdf4-3a2a3a41455d)


첫 RTT는 어떠한 동작이 아닌 핸드쉐이크 과정(there’s no receive and send)
다음 RTT에서 동작이 이루어짐 + 막대기가 넓을수록 파일 전송 시간이 더 걸림
∴ 2RTT + 파일 전송 시간 = 응답시간 → 따라서 지속성에서 더 빨리 걸리는 이유는 RTT를 반복하는 시간이 줄어들기 때문



![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/99729e11-a7c0-40a8-abdf-6a196aae4328)

데이터는 있을 수도 없을 수도 상황에 따라 다름
```
1번째 라인 : GET / POST / HEAD(커맨드) : 메시지의 전체적인 의미 // URL // HTTP 버전
2번째 라인 : 도메인 이름
3번째 라인 : 브라우저 이름
```

클라이언트 부분에는 보통 바디가 없음

```
GET : 웹페이지 URL 요청
HEAD : 문서의 내용 없이 타이틀만
POST : 서버에 요청하는 것(예: 네이버 검색시 텍스트 본문을 서버에 요청)
PUT : 파일 단위나 동영상 같은 용량 큰 것을 업로드하기 위한 요청 → 위키피디아, 이러닝 업로드 등
DELETE : 삭제 요청

⚠️ put / delete 는 위험
```
```
301 : 찾고자 하는 주소를 다른 곳에서 보내줌
400 : 이해를 못했을 때(예: 1.0버전만 이해하는 데 1.1로 보냈다던지..)
404 : 서버 주소를 못 찾는 경우
505 : 버전이 안맞는 것
```


웹캐시와 프록시 서버는 다름

웹캐시? 서버쪽에서 쿠키를 관리하는 것이 아닌 클라이언트에서 검색했던 기록을 저장하는 것
프록시 서버? 캐시메모리와 개념이 비슷 → 메모리와 cpu 사이 왔다갔다 하는 시간이 오래걸려서 자주 사용하는 시스템을 캐시에 저장한 후 캐시에서 꺼내서 쓰게 되면서 전체적인 속도를 향상시키기 위한 장치

오리지널 서버는 외부, 프록시 서버는 내부에 존재 → 프록시 서버에서 먼저 검색함 → 속도향상
Conditional GET : 프록시 서버와 오리지널 서버 사이에서 문서가 변형 되었는지, 해당 문서가 맞는지 알 수 없기 때문에 서로 교류하여 문서를 작성한 날자를 대조한 후, 문제가 없다면 문제가 없다는 메시지를 전송
만약 날짜가 다르면 오리지널 문서를 다시 보내줌

</div>
</details>


---

<details>
<summary>3장</summary>
<div markdown="1">       

![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/6d41d902-85fb-46dc-857e-cdc20ea5812f)

### 전송 계층의 서비스와 역할

> 프로세스 간 통신: 전송 계층은 송신 프로세스와 수신 프로세스 간의 통신을 담당한다. 이를 위해 포트 번호를 사용하여 프로세스를 식별하고, 데이터를 전송한다.
> 
> 신뢰성: 전송 계층은 데이터의 정확한 전송을 보장하기 위해 오류 검출과 복구 기능을 제공한다. 데이터의 손실, 손상, 중복, 순서 변경 등을 처리하여 신뢰성을 제공한다.
> 
> 흐름 제어: 전송 계층은 수신 측의 버퍼 오버플로우를 방지하기 위해 데이터의 흐름을 조절한다. 수신 측의 처리 속도에 맞춰 송신 측이 데이터를 전송할 수 있도록 합니다.

![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/4f511b98-75e6-4484-8341-4dab5a3810cd)


---


### TCP의 특징
```
1. 연결형 서비스로 가상 회선 방식을 제공
3-way handshaking 과정을 통해 연결을 설정하고, 4-way handshaking 과정을 통해 연결을 해제한다.

2. 흐름 제어(Flow control)
데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지

3. 혼잡 제어(Congestion control)
네트워크 내의 패킷 수가 과도하게 증가하지 않도록 방지

4. 높은 신뢰성을 보장
신뢰성이 높은 전송을 하기 때문에 UDP보다 속도가 느림

5. 전이중(Full-Duplex), 점대점(Point to Point) 방식
전이중(Full-Duplex) : 전송이 양방향으로 동시에 일어날 수 있다.
점대점(Point to Point) : 각 연결이 정확히 2개의 종단점을 가지고 있다.
```

![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/de22d927-f651-45e4-ba31-764d9c827cac)



### UDP의 특징
```
1. 비연결형 서비스로 데이터그램 방식을 제공한다.
데이터의 전송 순서가 바뀔 수 있다.

2. 데이터 수신 여부를 확인하지 않는다.
TCP의 3-way handshaking과 같은 과정 X

3. 신뢰성이 낮다.
흐름 제어(flow control)가 없어서 제대로 전송되었는지, 오류가 없는지 확인할 수 없다.

4. TCP보다 속도가 빠르다.

5. 1:1 , 1:N,N:N 통신이 가능하다.
```

![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/69cb2192-3453-40ef-af14-93f8e15b2a14)



UDP는 신뢰성 낮은 통신 프로토콜이므로 TCP보다 더 단순하다.
- 서버는 하나의 소켓만으로 통신한다. 
- 하나의 서버 소켓만 있으면 모든 클라이언트와 자유롭게 통신 가능


- dst IP, dst port로 데이터를 전송할 소켓을 구분한다. 
- 역다중화(demultiplexing) 중에 서버의 IP와 port가 같으면 동일한 서버 소켓으로 전송된다.


TCP는 보다 높은 신뢰성 보장을 위해 UDP보다 복잡하다.
- UDP와 달리, 하나의 클라이언트 소켓에 하나의 서버 소켓이 매핑된다. 
  ex) 네이버, 티스토리 등의 웹 페이지에 사용자 하나가 접속하면 그 사람을 위한 소켓 하나를 생성한다.
- 클라이언트 수만큼 소켓이 필요하므로 TCP는 UDP보다 네트워크 자원 소비가 큼


- 클라이언트가 서버를 찾기 위해 src IP/src Port, dst IP/dst Port를 사용한다. 
- 역다중화(demultiplexing) 중에 이 중 하나라도 다를 경우 다른 서버 소켓에 전송된다.
- UDP와 달리, dst IP, dst Port가 같아도 src IP, src Port가 다르면 서버의 다른 소켓으로 데이터가 전송됨 


---


### 다중화란?
전송(Transport) 계층에서 다중화(Multiplexing)란 애플리케이션(Application) 계층의 여러 개의 소켓에서 전송되는 데이터를 모아 하나로 모으는 것이다. 이렇게 모아진 메시지 데이터를 세그먼트(Segment)라 한다.
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/438331e6-e6d4-472a-8f1d-aa9cbc012d4a)

```
여러 개의 소켓에서 전송된 데이터를 다중화하면 세그먼트(Segment)가 된다.

다중화는 전송(Transport) 계층에서만 할 수 있는 것이 아니라, 어느 계층에서든 여러 곳에서 나온 데이터를 하나로 묶을 때에 사용한다.
전송 계층에서의 다중화 데이터는 세그먼트라 부르지만 네트워크 계층에서 다중화한 것은 다른 이름으로 부르는데, 그 경우에는 패킷이라 부른다.
계층마다 다중화했을 때 메시지의 이름이 다르므로 헷갈릴 수 있다.

이렇게 다중화한 메시지엔 헤더(Header)가 붙게 된다.
헤더란 메시지 앞에 붙은 정보를 말한다.
실제 전송하고자 하는 데이터는 헤더 다음에 붙게 된다.

그럼 헤더는 어떤 기능을 하느냐?
헤더는 우편 배달을 할 때 주소 역할을 한다.
데이터가 원하는 곳에 전달되고, 정상적으로 전달될 수 있도록 데이터를 포함하고 있다.
```

![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/16fe11be-b8fb-4e5c-bd65-4c358677868f)



### 역다중화란?
```
🔎 전송을 위해 여러 개를 하나로 묶는 것(Multiplexing)이 있다면, 전송이 되었을 때 이를 적절한 소켓에 전달해주는 것도 필요할 것이다.
   이를 역다중화(Demultiplexing)라 한다.
역다중화(demultiplexing)는 전송받은 세그먼트의 데이터를 적절한 소켓에 전달해주는 것이다.
mutliplexing이 여러 개를 하나로 묶어주고, demultiplexing은 반대로 하나의 데이터를 적절하게 분배해주는 역할을 한다.
```

- 헤더(header): 전송 측의 포트(source port number), 목표 포트(dest port number), 기타(other header fields)
- 데이터 : 메시지(application data, message)
- 포트 번호 :
  데이터가 상대에게 도달하면 전달받는 측(receiver)은 이를 역다중화(demultiplexing)하여 데이터를 적절한 소켓에 전달한다.
  여기서 전달해야 할 소켓을 고르기 위해 포트 번호를 통해 구분한다.
  전달하는 쪽의 포트 번호를 source port, 전달받는 쪽의 포트 번호를 dest port로 하여 헤더에 저장한다.

![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/f4e4a94c-480e-4017-aa40-af9e0c7578b2)

- header 필드의 수: 4개 → 단순한 구조로 되어 있다.
- source port 번호: 0~65535 (16 bits이므로 2^16 = 65536)
- destination port 번호: 이를 통해 역다중화(demultiplexing)을 함
- 길이(length) : UDP 세그먼트의 전체 바이트 길이. 본문(message)의 길이와 헤더(header)의 길이를 모두 포함한다.
- 체크섬(checksum) : 전송 도중에 데이터에 에러가 있는지 아닌지를 판단하기 위한 용도 
- checksum에 문제가 발생하면 에러가 발생했음을 확인하고 메세지를 버리게 된다.
- 이를 통해 udp는 mutliplexing/demutliplexing, 에러 체크 작업을 해주게 된다.


---
 

RDT(Reliable data transfer) 프로토콜은 TCP에서의 신뢰성을 보장해준다.


1. RDT 1.0: 완벽하게 데이터가 전송되었을 때
하위 계층이 신뢰성 높고(reliable) 완벽하게 데이터를 전송할 때이다.
그렇게 되면 전송(transport) 계층에서 데이터의 신뢰성을 준수할 필요가 없다. 데이터는 하위 계층을 거쳐 전송되므로, 이미 데이터의 신뢰성이 보장되는 셈이다.


2. RDT 2.0: 패킷 에러만 발생할 때
패킷 유실 없이 패킷 에러만 있는 채널을 타고 데이터가 전송될 때이다.
**에러 감지(Error detection)**
- 먼저 에러가 발생했는지를 알아봐야 한다.
- 여기서는 체크섬(checksum) 방법으로 데이터의 무결성을 확인한다. 


**피드백(Feedback)**
- receiver는 데이터를 잘 받았는지 확인하기 위해, 패킷을 받을 때마다 피드백을 주어야 한다.
- 잘 받았다면 ACKs(Acknowledgements), 에러가 발생하면 NAKs(Negative ACKs)을 전송
- 예를 들면, 친구랑 대화할 때 "어, 응"이라고 말하다가, 잘못 들을 경우 "어? 뭐라고?" 등으로 답한다. 이것과 똑같은 원리.


**재전송(Retransmission)**
- 패킷에 오류가 있으면 다시 전송해준다.
- sender가 NAK을 받게 되면 재전송한다.
- 반대로 ACK를 받게 되면 sender는 제대로 전달되었다고 확인하고, 다음 패킷을 전송한다.


3. RDT 2.1
- Sender가 패킷마다 시퀀스 번호(Sequence number)를 붙인다.
- 피드백(ACK/NAK) 메시지에 오류가 있는지 확인하고, 오류가 있으면 Sender는 현재 패킷을 재전송한다.
- Receiver는 복제된 패킷(Duplicate packet)을 버린다.
- 이외에는 RDT 2.0과 동일

**여기서 시퀀스 넘버는 몇 개까지 셀 수 있어야 할까?**
- 무한히 많은 수를 셀 수 있다면 좋겠지만 패킷의 헤더는 한계가 있다.
- 보내는 메시지의 길이가 커질수록 비용도 커지게 된다.
- 이전에 보낸 것과 같은지 아닌지만 구분할 수 있으면 된다. (복제 패킷을 확인하는 용도)
- 따라서 1비트(0, 1)만으로 표현할 수 있다.


4. RDT 2.2
여기서 NAK를 없앨 수도 있다.
RDT 2.1에서 무조건 Receiver가 ACK를 보내도록 하는 것이다.
그 대신 마지막으로 받은 정상적인 메시지가 무엇인지를 전송하는 것이다.
예를 들어 마지막으로 시퀀스 넘버가 2인 메시지를 받았다면, ACK 2를 전송한다.
마지막으로 받은 메시지는 시퀀스 넘버(Seq #)를 통해 알려준다.
3번 메시지를 전송했는데 ACK 2가 돌아오거나 ACK 메시지에 에러가 발생했다면, 3번 메시지를 재전송하는 것이다.

5. RDT 3.0: 패킷 유실, 패킷 에러가 발생할 때
대표적인 예시는 카카오톡에서 전송 실패가 뜨는 것이 있겠다.
카카오톡 서버가 불안정할 때나 아예 인터넷에 접속이 안 될 때면 위 사진처럼 발송에 실패하곤 한다.
이 상황이 바로 **패킷 유실(Packet loss)**이다.

이때, 카톡에서는 메시지를 보내고 바로 전달 실패가 되는 것이 아니라 한참이 지나고 나서야 전송이 실패되었다고 알려준다.
어느 정도 시간이 지날 때까지 기다리고 나서도 피드백이 오지 않으면 전송에 실패했다고 판단하는 것이다.

신뢰성 낮은 채널(Unreliable channel)에서는 두 가지 현상이 발생함 
```
- 패킷 에러(Packet error)
- 패킷 유실(Packet loss)
- 패킷 에러(Packet error)에 대한 대응책 
- 에러 감지(error detection), 피드백(feedback), 재전송(retransmission), 시퀀스 넘버(sequence number)
- 패킷 유실(Packet loss)을 위한 대응책 
- 타임 아웃(Timeout)
```

**파이프라인 프로토콜(Pipelined protocol)**
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/aa1b4f3e-bcc2-4f50-9a7f-7cb299e14d29)

한 번에 많은 메시지를 보내고 한 번에 응답을 받는 것이 당연히 더 효율적이다.
신뢰성 있는 파이프라인 프로토콜을 구축하기 위한 방법에는 대표적으로 두 가지가 있다.

- Go-Back-N
- Selective repeat


Go-Back-N
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/361c7115-7829-4289-81ed-c9ad7a66364f)

imeout시 을 재전송한다.
윈도우 내의 **모든 패킷**

- timeout이 발생하면, 윈도우 사이즈(window size)가 N일 때 전송할 대상도 N만큼 다시 돌아오게 된다.
- 윈도우에 들어 있는 데이터는 버퍼(buffer)에 저장하고 있어야 한다.
- 윈도우 밖(0, 1): ACK가 왔으므로 전송이 완료됨 → 버퍼에 저장하지 않음
- 윈도우 내(2, 3, 4, 5): ACK가 오지 않아 제대로 전송되었는지 알 수 없다. → 버퍼에 저장해야 한다.


**Go-Back-N의 문제점**
Go-Back-N의 문제점은 정상 전송된 패킷이 버려지고 재전송된다는 점이다.
실제로는 윈도우 사이즈가 4 정도로 작지 않다.
원래라면 실패할 경우 그 패킷만 재전송하면 된다.
그러나 Go-Back-N에 따르면 한 패킷만 전송에 실패해도 윈도우 내에 있는 모든 패킷을 재전송해야 한다.


**Selective Repeat**
Selective Repeat는 패킷이 유실되어 재전송할 때 선별적으로 패킷을 재전송한다.
Go-Back-N처럼 ACK를 누적(cumulative) 방식으로 보내게 되면 어디까지 패킷이 전송되었는지 알 수 없다.


따라서 Selective Repeat에서는 패킷을 받을 때마다 각각 ACK를 전송시켜준다.
예를 들어 7번 패킷을 받으면 ACK 7을 보내는데, 여기서 ACK 7은 7번까지 모두 받았다는 것이 아니라 7번 패킷을 받았다는 뜻이다.
ACK 7을 받게 되면 7번 패킷을 윈도우에서 해제해준다.


그러나 패킷이 순서대로 정렬되어야 하므로 패킷이 유실되었을 때, 그 패킷이 도착할 때까지 다음 순서의 패킷을 임시로 저장해 줄 필요가 있다.


따라서 2번 패킷을 받지 못하고 3, 4번 패킷을 받았을 때 이를 recv 버퍼에 저장해주게 된다.


 
---



### TCP Overview

- **point-to-point**
  - 한 프로세스에는 무조건 한 프로세스가 매핑된다.
  - sender 하나에 receiver 하나가 연결된다.


- **reliable, in-order byte**
  - 신뢰성이 보장되므로 데이터가 유실되거나 데이터에 에러가 발생하지 않는다.
  - 전송하면 데이터가  전송된다. 순서대로

- **pipelined**
  - 파이프라인 방법을 사용하여, 한 번에 데이터를 쏟아붓는다
  - ACK가 돌아올 때까지 기다리지 않고 다음 데이터를 전송한다.

- **full duplex data**
  - 같은 연결에서  데이터가 전송된다.
  - 서버, 클라이언트 모두 서로에게 데이터를 전송할 수 있다. 즉, 모든 서버와 클라이언트는 이다.
  sender이자 receiver

- **sender, receiver buffer**
  - sender는 전송해야 할 데이터를 저장하기 위해 버퍼(buffer)를 사용한다.
  - receiver는 순서가 뒤바뀐 바이트를 바이트를 받기 위해 버퍼를 사용한다.
  - 모두 sender이자 receiver이므로 모든 디바이스는 와 를 갖는다.
    sender 버퍼
    receiver 버퍼

- **flow controlled**
  - sender는 receiver가 만 패킷을 전송할 수 있다.


![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/36737e7d-a37b-4cc4-be6b-f08d4f544632)



- **포트 번호TCP**는 다중화(mutliplexing)와 역다중화(demultiplexing) 과정을 위해 출발지와 도착지의 포트 번호를 요구한다. 포트 번호는 각각 16비트씩 할당되어 총 32비트로 구성된다.

- 시퀀스 번호(sequence number)는 세그먼트 데이터의 의 바이트 스트림 번호(byte stream number)를 나타낸다. 100바이트를 전송할 때 첫 메시지(세그먼트)는 0~9번 바이트, 두 번째 메시지는 10~29번 바이트까지 보낸다고 하자. 그러면 첫 메시지의 seq #(시퀀스 넘버) = 0이고, 두 번째 메시지의 seq # = 10이 된다.
첫 바이트

- acknowledgement numberacknowledgement number는 ACK 번호를 가리킨다. 주의할 점은, TCP에서의 ACK는 이다. 지난 포스팅에서 Go-Back-N에서는 ACK 10이 '10번 세그먼트까지 받았음'을 의미하지만, TCP는 '9번 세그먼트까지 받았고 10번을 받을 차례'를 의미한다. Go-Back-N과 동일하게 ACK가 누적(cumulative)한 방식이지만 그 번호가 갖는 의미가 약간 다른 셈이다.
'다음번에 받을 바이트의 seq #'

- checksum 체크섬은 에러를 발견하기 위해 사용한다.

- Receive windowreceive window는 현재 receiver가 수신할 수 있는 바이트의 수를 말한다. receive 버퍼에 남은 공간이 얼마나 되는지를 가리킨다.


**Reliable data transfer**

TCP에서 보장하는 rdt(Reliable data transfer) 서비스는 기존 rdt와 비교하여 세 가지 차이점이 있다.

  1. 파이프라인 방식으로 세그먼트를 전송
  2. 누적 확인 응답(Cumulative acks)
  3. TCP는 재전송을 위해 단일타이머를 사용함

또한 TCP는 Go-Back-N과 달리, timeout이 발생하면 해당 세그먼트만 전송하게 된다.



---

 

**흐름제어**

만약 수신 측의 recv 버퍼가 꽉 찼을 경우 송신하는 측에서는 데이터를 전송하지 않는다. 이렇게 전송자가 너무 많이, 빨리 전송하여 수신자의 버퍼가 넘치는 일이 없도록 하는 것을 흐름 제어(Flow control)이라 한다.


### TCP 3-Way Handshake
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/a9759f9a-5e9c-493d-b39d-0392ff40e486)

TCP 연결 과정(3-way handshake)


TCP에서는 클라이언트와 서버 간에 연결을 구축하기 위해 3-way handshake 방법을 사용한다.
3-way handshake는 이름 그대로 세 번 '악수'하는 과정으로 연결을 구축한다.
그 세 과정은 다음과 같다.
```
SYN: 클라이언트가 서버에 연결을 요청
- 클라이언트의 Seq #를 서버에 알려준다.
- SYN 메시지를 보낸다는 것은 TCP 커넥션을 열기를 요청하는 것이다.
- TCP Header에 있는 를 통해 올릴 수 있다.
```

SYN/ACK: 서버가 클라이언트에게서 SYN을 받고 SYNACK 세그먼트를 전송
- 서버의 Seq #를 클라이언트에 알려준다.
- 이 과정에서 서버가 버퍼를 만든다.
- TCP Header에 있는 와 syn 신호, ack 신호를 이용한다.

ACK: 클라이언트가 SYNACK를 받고 서버에 ACK를 보내줌
- ACK 과정에서는 클라이언트가 서버에 실제 데이터를 담아 보낼 수 있다.
- 왜 SYNACK 과정과 ACK 과정이 필요할까? 
- 클라이언트는 두 번째 과정 SYNACK를 통해 제대로 메시지가 전송됨을 알 수 있다.
- 그러나 서버는 ACK 과정이 없으면 메시지가 전송되긴 하지만 정상적으로 전송되었는지 알 수 없기 때문.


TCP 연결 끊기(4-way Handshake)
3-way handshake가 3번 메시지가 오고 가서 3-way라면, TCP 연결 종료는 4번 메시지가 오고 가므로 4-way handshake라 한다.
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/f63cbc7a-98b9-4cc7-8ce5-40e95eddfc75)

TCP 연결 종료 과정(4-way handshake)
- FIN: 클라이언트가 서버에게 FIN을 전송 
  - 클라이언트 장치가 서버에게 FIN을 보내서 연결 종료를 알린다.

- ACK: 서버가 클라이언트에게 ACK를 전송 
  - 클라이언트 to 서버 연결 종료 확인 과정
  - 서버는 클라이언트의 연결 중단 요청을 확인하고 피드백으로 ACK를 보내어준다.
- FIN: 서버가 클라이언트에게 FIN을 전송 
  - 이번엔 반대로 서버의 연결 중단을 클라이언트에게 고지한다.
  - 클라이언트가 FIN을 수신하면 잠시 동안 timed wait 상태가 되어 연결 종료를 통지받고도 한참 동안 종료되지 않는다.

- ACK: 클라이언트가 서버에게 ACK를 전송 
  - 서버 to 클라이언트 연결 종료 확인 과정
  - 서버가 ACK를 받고 나면 TCP 연결이 종료된다.

---

### 혼잡 제어가 하는 일
```
기본적으로 네트워크는 공공의 것(public)으로 소유자가 없다.
누구도 소유하고 있지 않기 때문에 따로 제어하지 않으면 각 기기들은 자유롭게 네트워크를 사용하다가 데이터를 최대한 많이 보내게 된다.

그러나 데이터가 너무 많이 보내지면 문제가 발생한다.
라우터에는 한계가 있기 때문에 데이터 전송량이 많아지면 네트워크의 상태가 안 좋아지고 막히게 된다. 데이터 전송이 원활하지 않게 되는 것이다.

여기서 문제점은 TCP는 '데이터 전송이 잘 안 되면 재전송을 한다'는 점이다.

지금까지 배운 것에 따르면, TCP는 데이터에 오류가 발생하거나 타임아웃이 발생하면 데이터를 재전송한다. 네트워크 상태가 악화될수록 재전송이 잦아져서 더 많은 데이터를 보내고, 상태를 더 악화시키게 된다. TCP는 상태가 안 좋을수록 상태를 더 악화시킨다.


이를 해결하려면 아예 네트워크가 막히지 않게 적당히 조절하는 작업이 필요하다.
네트워크의 소유자는 아무도 없기 때문에 네트워크를 이용하는 각자가 데이터 전송량을 줄이게 된다. 이러한 점에서 TCP는 독립적으로 동작하되 서로 양보해주는 경향을 보인다.
네트워크 상황이 안 좋으면 데이터 전송량을 줄이고, 좋으면 전송량을 늘려준다.
```

</div>
</details>


---

<details>
<summary>4장</summary>
<div markdown="1">       

- 버전4bitIP 버전 번호 인식
- priorityflows에서 데이터그램 사이에 우선순위 식별
- 플로우 레이블20bit흐름 인식플로우 별로 디테일한 제어
- 페이로드 길이16bitIPv6 데이터그램에서 고정 길이 40byte 패킷 헤더 뒤에 나오는 바이트 길이부호없는 정수옵션들 모두 처리하도록 설계헤더 고정 -> 시작점 따로 명시 불필요
- 다음 헤더자신의 페이로드가 어떤 것인지 구분데이터그램의 내용이 전달될 프로토콜(ex. TCP, UDP) 구분IPv4에도 있던 것
- 홉 제한라우터가 데이터그램을 전달할 때마다 1씩 감소홉 제한 수가 0보다 작아지면 라우터는 데이터그램을 버림


네트워크 계층의 역할? 송신 호스트에서 수신 호스트로 패킷을 전달하는 것


**네트워크 계층에서 제공하는 서비스**

1. 보장된 전달
2. 지연 제한 이내의 보장된 전달
3. 순서화 패킷 전달 : 순서대로 도착하는 것을 보장
4. 최소 대역폭 보장 : 특정한 비트율의 전송 링크를 에뮬레이트
5. 보안 서비스 : 트랜스포트 계층의 모든 세그먼트에 대한 기밀성 유지


**포워딩(전달)**
```
패킷이 라우터의 입력 링크에 도달했을 때 라우터는 그 패킷을 적절한 출력 링크로 이동시켜야 한다.
포워딩에서 예외적으로 가장 보편적이고 중요한 한 기능이 데이터 평면에서 실행한다.
매우 짧은 시간(나노초)단위 → 하드웨어에서 실행한다.
```

**라우팅**
: 송신자가 수신자에게 패킷을 전송할 때 네트워크 계층은 패킷 경로를 결정한다.
- 라우팅 알고리즘
긴 시간(초)단위 → 네트워크 전반에 걸쳐 출발지에서 목적지까지 데이터그램의 종단 간 경로 결정, 소프트웨어에서 실행한다.


![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/96fb6795-6095-4533-82a6-a24e1fa7e1a1)


- 라우터는 도착하는 패킷 헤더의 필드값을 조사하여 패킷 전달한다.
- 필드값 → 포워딩 테이블의 내부 색인으로 사용한다.
- 포워딩 테이블 헤더의 값 = 해당 패킷이 전달되어야 할 라우터의 외부 링크 인터페이스, 패킷의 목적지 주소 or 패킷이 속한 연결의 지시한다.


--


**제어 평면: 전통적인 접근 방법**

- 라우팅(제어 평면)과 포워딩(데이터 평면) 사이의 상호작용으로 포워딩 테이블 구성한다.
- 라우팅 알고리즘 라우터의 포워딩 테이블의 내용 결정각각의 모든 라우터에서 실행 라우터가 포워딩과 라우팅 기능 수행한 라우터의 라우팅 알고리즘 기능은 다른 라우터의 것과 소통 → 포워딩 테이블의 값 계산소통
```
⭐️ 라우팅 프로토콜에 따라 라우팅 정보에 포함된 라우팅 메시지를 교환제어 평면과 상호작용 한다.
⭐️ 각 라우터는 다른 라우팅 구성요소와 소통하기 위한 라우팅 구성요소를 갖고 있다
```


![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/5a5005c0-8054-4328-9928-264d84d8f049)


- 인간이 포워딩 테이블을 수동으로 구성할 수 있다? → 제어 평면 기능이 데이터 평면에서의 포워딩 테이블의 내용 결정하는 방법이다.
- 물리적으로 분리된 라우터로부터, 원격 컨트롤러 컴퓨터와 각각의 라우터에 의해 사용될 포워딩 테이블을 분배하는 다른 접근법
- 원격 컨트롤러 : 높은 신뢰성과 중복성을 갖춘 원격 데이터 센터에 설치ISP, 제3자에 의해 관리됨.
- 어떻게 라우터, 원격 컨트롤러 소통? 포워딩 테이블과 그 밖의 라우팅 정보를 포함한 메시지 교환네트워크가 '소프트웨어적으로 정의되었을 때', 포워딩 테이블을 계산하는 컨트롤러는 라우터와 상호작용을 하며 소프트웨어에서 실행한다.



---


![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/c860cbdf-6a31-47f8-92cb-c58439c26a96)


1. 입력 포트

- 초록색
  - 라우터로 들어오는 입력 링크 → 물리 계층 기능

- 파란색
  - 들어오는 링크의 반대편에 있는 링크 계층과 상호 운용 → 링크 계층 기능

- 빨간색
  - ⭐️입력 포트에서 검색 기능 수행 ⭐️
  - 포워딩 테이블 참조 → 도착된 패킷이 스위치 구조를 통해 라우터 출력 포트 결정
  - 제어패킷(라우팅 프로토콜 정보 전달)은 입력 포트에서 라우팅 프로세서로 전달
  - 데이터그램이 스위치 구조 포워딩 속도보다 더 빨리 도착하면 input port queuing 발생


**포워딩**
```
destination-based forwarding 목적지 기반 포워딩 : 오직 최종 목적지 IP 주소만을 기반으로 포워딩
generalized forwarding 일반화된 포워딩 : 헤더 필드값의 많은 요소들이 포워딩에 관여
```

2. 스위치 구조
- 라우터의 입력 포트와 출력 포트 연결
- 라우터 내부에 포함되어 있음.
- 네트워크 라우터의 내부 네트워크
- 예) 원형 교차로


3. 출력 포트

- 스위치 구조에서 수신한 패킷 저장
- 필요한 링크 계층 및 물리 계층 기능 수행 → 출력 링크로 패킷 전송
- 일반적으로 동일한 링크의 입력 포트와 한 쌍


4. 라우팅 프로세서

**제어 평면 기능 수행**
  - 기존 라우터 : 라우팅 프로토콜 실행, 라우팅 테이블과 연결된 링크 상태 정보 유지 관리, 포워딩 테이블 계산
  - SDN 라우터 : 원격 컨트롤러와 통신, 포워딩 테이블 엔트리 수신, 라우터의 입력 포트에 해당 엔트리 설치

**네트워크 관리 기능 수행**
라우터 ? 포워딩 테이블로 도착 패킷이 스위치 구조를 통해 전달되는 출력 포트를 검색
포워딩 테이블? 라우팅 프로세서에서 계산, 갱신, 원격 SDN 컨트롤러에서 수신라우팅 프로세서에서 입력 라인 카드로 복사 → 패킷 단위로 중앙 집중식 라우팅 프로세서 호출 안함, 병목 현상 방지

**스위칭**

![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/355865fb-dacd-40ef-9c7a-5307ebe4e085)

- 입력 링크에서 적절한 출력 링크로 패킷 전송
- 패킷이 입력포트에서 출력포트로 실제로 스위칭(포워딩)되는 구조를 통과
- 라우터의 핵심
- 스위칭 속도 : 패킷을 입력에서 출력으로 전송할 수 있는 속도종종 입력/출력 라인 속도의 배수로 측정됨.


![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/be3bdcc0-a077-4412-bcb5-d799c86d3164)


1. 메모리를 통한 교환

- CPU(라우팅 프로세서)를 직접 제어하던 가장 단순한 초기의 라우터
- 시스템 메모리에 복사된 패킷
- 메모리 대역폭에 의해 제한된 속도
- 공유 시스템 버스 -> 두 패킷 동시 전달 불가

2. 버스를 통한 교환

- 입력 포트는 라우팅 프로세서의 개입없이 공유 버스를 통해 직접 출력 포트로 패킷 전송
- 모든 출력 포트에 패킷 수신 -> 레이블과 매치되는 포트만 패킷 유지
- 버스 대역폭에 의해 제한된 전환 속도
- 모든 패킷이 하나의 버스를 건너가야 함. 한 번의 하나의 패킷만 통과 가능.
- 종종 작은 지역 및 기업 네트워크에서 작동하는 라우터에서 사용하기에 충분
- 32Gbps 버스, Cisco 5600 : 액세스 라우터에 충분한 속도
  
3. 상호연결 네트워크를 통한 교환
- 공유 버스의 대역폭 제한 극복


크로스바 스위치
- N개의 입력포트를 N개의 출력 포트에 연결하는 2N버스로 구성된 상호 연결 네트워크
- 수직 버스는 수평 버스와 교차점에서 교차, 스위치 구조 컨트롤러에 의해 언제든지 열거나 닫을 수 있음. → 여러 패킷 병렬 전달 가능
- 서로 다른 입력 포트에서 나오는 패킷이 동일한 출력 포트로 보내지는 경우 차단.

다단계(multistage) 스위치
- 좀 더 정교한 상호연결 네트워크
- 각기 다른 입력 포트의 패킷이 동일한 출력 포트를 향해 동시 전달 가능
- 데이터그램을 고정된 길이의 셀로 분할
- K개의 작은 청크로 분해 → 출력 포트에서 원래의 패킷으로 재조합


---


**출력포트처리**
출력 포트의 메모리에 저장된 패킷을 가져와서 출력 링크를 통해 전송
전송을 위한 패킷 선택(스케줄링), 큐 제거, 필요한 링크 계층 및 물리 계층 전송 기능 수행

- 큐의 위치와 범위 : 트래픽 로드, 스위치 구조의 상대 속도 및 라인 속도에 따라서 달라진다.
- 큐가 커지면 라우터의 메모리가 소모, 도착하는 패킷을 저장할 수 있는 메모리가 없을 경우 패킷 손실 발생
- 입력 및 출력 라인의 속도(전송률) : 초당 R(line) 패킷
- 스위치 구조 전송률 R(switch) : 패킷이 입력포트에서 출력포트로 이동할 수 있는 속도
- R(switch) > R(line)*N → 입력 포트에서 발생하는 큐잉 무시, 다음 배치 작업이 도착하기 전에 스위치 구조를 통해 삭제 가능

![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/dee5ecc9-3c40-441b-84f3-292f1289c69a)


- HOL(head-of-the-line) 차단(블로킹)- 빨간박스 둘이 충돌 → 하단 빨간 박스 대기 → 초록박스가 사용할 출력 포트가 사용 중이지 않아도 앞에 빨간박스의 대기 때문에 초록박스가 기다려야하는 현상 → 패킷 손실이 증가

![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/7473093b-cf44-4489-aeb3-3a6030c34ec9)


**Buffering?**
스위치를 통한 도착 속도가 출력 라인 속도를 초과할 경우 발생
출력 포트 버퍼 오버플로로 인한 대기열(지연) 및 손실

**버퍼관리?**
- Drop-tail 정책 : 들어오는 패킷을 저장할 메모리가 충분하지 않을 때 도착한 패킷을 삭제
이미 대기 중인 하나 이상의 패킷을 제거하여 새로 도착한 패킷을 저장하기 위한 공간 확보 필요
정체, 버퍼 부족으로 인해 데이터그램 손실 가능

- Sheduling discipline : 전송을 위해 대기중인 데이터그램 중에서 선택
- 우선순위 스케줄링 : 최고의 성능, 네트워크의 중립성
- 신호 정체로 표시할 패킷 : ECN, RED
- 링크 용량 C
- 버퍼링의 양 B = RTT(250msec)
- 필요한 버퍼의 양 = RTT * C
- 많은 수의 독립적인 TCP 흐름 N
- 많은 수의 독립적인 TCP 흐름이 링크를 통과할 때 필요한 버퍼링 = ![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/fc9f188f-8533-4a58-9599-8b0ec5154c58)
- 과도한 버퍼링 : 큐잉 지연 증가> 링크는 충분히 꽉 차게 유지하되, 더 꽉 차게 유지하지 않는다. (양날의 검)



---


**패킷 스케줄링 ?** 링크에서 다음으로 보낼 패킷 결정


**Fist Come, First Served**
FIFO (First In, First Out) 방식
출력 링크 큐에 도착한 순서와 동일한 순서로 출력 링크에서 전송할 패킷 선택


**Priority**


![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/7b69dd5d-f3d2-4a10-9996-20103178c846)



- 출력 링크에 도착한 패킷은 큐에 도착하면 우선순위 클래스로 분류
- 가장 높은 우선순위 클래스에서 패킷을 전송
- 우선순위 동일 → FCFS 방식으로 수행
- 비선점 우선순위 큐잉 : 패킷 2의 전송 중에 우선 순위가 더 높은 패킷 4가 도착하더라도, 패킷의 전송이 시작되면 중단하지 않으므로 패킷 4는 전송을 위해 대기.


**Round robin**

![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/db1e68ab-d558-4713-84b7-924ffe3a1702)

- 우선순위 큐잉과 같이 클래스로 분류
- 클래스 간 엄격한 서비스 우선순위가 존재 X
- 클래스 간에 서비스를 번갈아서 제공: 클래스1 -> 클래스2 -> 클래스3 -> 클래스1 -> ...
- 작업 보존 큐잉 : 유휴 상태 허용 X, 다음 클래스 즉시 검사


**Weighted fair queueing**
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/e405cacb-13d1-462b-92c8-13d55a773df0)

- Round Robin의 일반화된 형태
- RR과의 차이점 : 각 클래스마다 다른 양의 서비스 시간을 부여
- 각 클래스 i 는 가중치(W(i)) 할당 받음
- 최소 대역폭 보장

 
---


![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/ecead494-b01c-4975-8436-df7e69357ec7)

버전 번호
- 4bit
- IP 프로토콜 버전 명시
- 라우터 : 버전 번호 확인하여 데이터그램의 나머지 부분 어떻게 해석할 지 결정


헤더 길이
- 헤더에 가변 길이의 옵션 포함
- 4bit
- IP 데이터그램에서 실제 페이로드가 시작하는 곳을 결정
- 대부분의 IPv4 데이터그램 헤더는 20바이트


서비스 타입(TOS)
- 각기 다른 유형의 IP 데이터그램을 구별
- TOS 비트 중 2개는 명시적 혼잡 알림에 사용
- 예) 실시간 데이터그램(전화통신 앱)과 비실시간 트래픽(FTP) 구분에 유용


데이터그램 길이
- 바이트로 계산한 IP 데이터그램의 전체 길이 (헤더 + 데이터)
- 16bit


식별자, 플래스, 단편화 오프셋
- IP 단편화 관련
- 큰 IP 데이터그램 → 여러 개의 작은 IP 데이터그램으로 분할


TTL(time-to-live)
- 데이터그램의 무한 순환(라우팅 루프) 방지
- 라우터가 데이터그램을 처리할 때마다 감소
- TTL = 0 : 라우터가 데이터그램 폐기

프로토콜
- IP 데이터그램이 최종 목적지에 도착했을 때만 사용
- 데이터 부분이 전달될 목적지의 트랜스포트 계층의 특정 프로토콜을 명시
- 예) TCP, UDP 사용할 것을 명시프로토콜 번호의 역할 = 트랜스포트 계층 세그먼트에서 포트 번호 필드의 역할

헤더 체크섬
- 라우터가 수신한 IP 데이터그램의 비트 오류 탐지에 도움
- 헤더에서 각 2바이트를 수로 처리 후 1의 보수를 합산
- 수신한 헤더 체크섬 == 데이터그램 헤더의 체크섬 : 오류X

출발지와 목적지 IP 주소
- 출발지가 데이터그램 생성 시, 각 필드에 출발지, 목적지 주소 삽입
- DNS 검색을 통해 목적지 주소 결정


옵션
- IP헤더 확장
- 헤더 옵션 필드에 정보 포함X → 오버헤드 해결
- 데이터그램 헤더가 가변길이로 데이터 필드 시작점을 초기에 결정 불가능
- 옵션 : 문제 복잡하게 만듬.
- 옵션 처리 유무 → 라우터에서 IP데이터그램 처리하는 데 필요한 시간 좌우


데이터 페이로드
- 데이터그램이 존재하는 이유이자 가장 중요한 마지막 필드
- 목적지에 전달하기 위해 트랜스포트 계층 세그먼트를 포함


IPv4 주소체계
- 호스트 IP가 데이터그램을 보낼 때, 네트워크와 연결되는 하나의 링크를 통해 데이터링크를 보낸다.
- 인터페이스 = 호스트/라우터와 링크 사이의 경계
- 호스트는 하나 또는 두개의 인터페이스 (ex. 유선 이더넷, 무선)
- 라우터는 여러 개의 인터페이스
- IP주소는 인터페이스와 관련
- 32bit (4byte)2^32개 (약 40억 개)의 주소 사용 가능
- 십진 표기법
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/5c206633-ee08-4907-86a0-1c250a31346d)
- 모든 호스트와 라우터의 각 인터페이스는 고유한 IP주소를 가짐.
- 인터페이스의 연결3개의 인터페이스를 갖는 하나의 라우터, 라우터에 의해 연결된 7개의 호스트
- 라우터와 호스트는 IP 주소의 왼쪽 24bit가 동일
- 왼쪽 3개의 호스트 : 이더넷 스위치에 의해 연결된 이더넷 인터페이스
- 아래 2개의 호스트 : 무선 와이파이 인터페이스
- ![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/58f1bad0-1e31-43d2-8739-65cfa1a4bd03)


---


**서브넷?**
간섭 라우터를 통과하지 않고 물리적으로 서로 연결할 수 있는 장치 인터페이스
```
서브넷을 정의하려면?
호스트나 라우터에서 각 인터페이스를 분리하고 고립된 네트워크 만든다.
이 고립된 네트워크의 종단점 = 인터페이스의 끝 → 고립된 네트워크 각각이 서브넷이 됨. → 라우터끼리 연결하는 것도 하나의 서브넷이다.
```

DHCP? 주소의 호스트 부분을 얻는 방법


IP주소를 얻는 방법
- 주소의 호스트 부분을 얻는 방법
- 주소의 네트워크(서브넷) 부분을 얻는 방법


호스트 IP 주소 얻는 방법
- 구성 파일의 sysadmin → 하드 코딩
- DHCP : Dynamic Host Configuration Protocol → 동적으로 가져옴.


### DHCP 목적
```
1. 호스트가 네트워크에 '가입'할 때 네트워크 서버에서 IP주소를 동적으로 가져옴. "plug and play"
2. 사용 중인 주소 임의로 갱신 가능
3. 주소 재사용 가능 (연결/켜짐 상태에서만 주소 유지)
4. DHCP서버가 DHCP 제공
5. 네트워크에 들어오는 모바일 사용자 지원

DHCP는 클라이언트-서버 프로토콜
클라이언트 : 일반적으로 IP 주소를 포함하며 네트워크 설정을 위한 정보를 얻고자 새롭게 도착한 호스트
DHCP 서버 : 라우터와 함께 위치함. 라우터가 릴레이 역할을 하기 때문에 해당 라우터에 연결된 모든 서브넷에 제공할 수 있음.
```

### NAT (Network Address Translation)
```
SOHO (Small Office, Home Office)의 확산
모든 IP 장치를 수용할 수 있는 주소 범위 할당
네트워크 주소 변환으로 해결
외부에 관한 한 로컬 네트워크의 모든 장치는 하나의 IPv4 주소만 공유
로컬 네트워크로 나가는 모든 데이터그램은 동일한 소스 NAT IP 주소 138.76.29.7를 가짐. -> 소스 포트 번호는 다름.
이 네트워크에서 source/destination에 있는 데이터그램은 source, destination에 대해 10.0.0/24 주소를 가짐.
로컬 네트워크의 모든 장치에는 로컬 네트워크에서만 사용할 수 있는 사설 IP주소공간에 32bit 주소가 존재
```
**장점**
- 모든 장치에 대해 공급자 ISP에서 하나의 IP 주소만 필요
- 외부에 알리지 않고 로컬 네트워크의 호스트 주소 변경 가능
- 로컬 네트워크에서 장치의 주소를 변경하지 않고 ISP 변경 가능
- 보안 : 로컬 네트워크 내부의 장치는 직접 주소 지정X, 볼 수 X

NAT 역할 ? NAT라우터는 투명하게 구현되어야 한다.


![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/a7ce8251-0797-4305-829e-3981a6f1a925)


- 나가는 datagrams 헤더 변경: 내부에서 사용하는 IP 포트 번호 대신 라우터 IP 주소와 새로운 포트 번호를 설정(Source IP address, port #) → (NAT IP address, new port #)
- NAT 변환 테이블 기억
- 수신 데이터그램의 대상 필드에서 NAT테이블에 저장된 해당 필드로 변경: (NAT IP address, new port #) → (Source IP address, port #)


### IPv6 주소체계

- 32bit 주소 공간 할당
- 간소화된 40byte 고정된 헤더 길이 -> 빠른 프로세싱/포워딩
- "flows"라는 개념 채택 : 패킷 단위가 아닌, 하나하나 어떤 서비스의 흐름들끼리 디테일한 제어 가능
- IPv4보다 심플한 구조
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/89e5e9e3-a249-469e-8c24-6b37c2b8439a)


버전
- 4bit
- IP 버전 번호 인식

priority
- flows에서 데이터그램 사이에 우선순위 식별

플로우 레이블
- 20bit
- 흐름 인식플로우 별로 디테일 한 제어

페이로드 길이
- 16bit
- IPv6 데이터그램에서 고정 길이 40byte 패킷 헤더 뒤에 나오는 바이트 길이
- 부호없는 정수옵션들 모두 처리하도록 설계
- 헤더 고정 → 시작점 따로 명시 불필요

다음 헤더
- 자신의 페이로드가 어떤 것인지 구분
- 데이터그램의 내용이 전달될 프로토콜(ex. TCP, UDP) 구분
- IPv4에도 있던 것

홉 제한
- 라우터가 데이터그램을 전달할 때마다 1씩 감소
- 홉 제한 수가 0보다 작아지면 라우터는 데이터그램을 버림



</div>
</details>


---


<details>
<summary>5장</summary>
<div markdown="1">       


### 라우팅 알고리즘 분류
global
- 모든 라우터들이 완벽한 topology를 가짐 → 모두의 가진 정보가 동일
- 정보가 모두 브로드캐스팅
- "link state" 알고리즘 : 네트워크 전체 정보를 이용

decentralized
- 자신의 정보를 가장 가까이에 있는 곳에만 뿌려서 이웃을 통해 다음으로 넘어가게끔 만드는 알고리즘.
- "distance vector" 알고리즘 : 반복적, 비동기적, 분산적

state
- 라우터가 천천히 변한다.

dynamic
- 라우터가 빠르게 변한다.
- 주기적 업데이트, 링크 비용 변경에 대한 응답
- 라우팅 프로토콜 돌렸을 때 자동으로 테이블이 생성


---


### 링크 상태(LS) 라우팅 알고리즘

- 중앙 집중형 라우팅 알고리즘
- 초기화 단계와 반복 부분으로 구성
- 노드의 개수만큼 반복
- 네트워크 토폴로지, 모든 노드에 알려진 링크 비용
- 링크 상태 브로드 캐스트를 통해 달성.
- 모든 노드가 동일한 정보를 가짐.

**다익스트라 알고리즘**
- 하나의 노드에서 네트워크 내 다른 모든 노드로의 최소 비용 경로를 계산
- D(v) : 알고리즘의 현재 반복 시점에서 출발지 노드부터 목적지 v까지의 최소 비용 경로의 비용
- p(v) : 출발지에서 v까지의 현재 최소 비용 경로에서 v의 직전 노드
- N' : 노드의 집합. 출발지에서 v까지의 최소 비용 경로가 명확히 알려져 있다면, v는 N'에 포함.
다익스트라 알고리즘 한계? 
  - 시간 복잡도 : O(n^2)
  - 진동(oscillation) 문제 : 교통량에 따라 링크 비용 변화하는 경우 경로 변동 가능성


**거리 벡터(DV) 라우팅 알고리즘**
특징
- 분산적 : 각 노드는 하나 이상의 직접 연결된 이웃으로부터 정보르르 받고 계산을 수행하여 계산된 결과를 다시 그 이웃들에게 배포한다.
- 반복적 : 이웃끼리 더 이상 정보를 교환하지 않을 때까지 프로세스가 지속된다. (자기 종료)
- 비동기적 : 톱니바퀴 돌듯이 모든 노드가 서로 정확히 맞물려 동작할 필요가 없다.

**벨만-포드 Bellman-Ford 알고리즘**
- dx(y) : 노드 x부터 y까지 최소 비용 경로의 비용
 
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/6ff543f0-de4d-42d0-987e-49c1276ebb9d)


- 이웃간 통신의 형식을 제안.
- 각 노드는 이웃으로부터의 갱신을 기다림.
- 업데이트를 수신하면 새로 거리 벡터를 계산
- 거리 벡터가 갱신될 경우 이웃 노드에 전파


---


**LS와 DV 알고리즘 비교**
메시지 복잡도
- LS : n개의 라우터, O(n^2)의 메시지
-DV : 이웃 간의 교환, 수렴 시간 다양

수렴 속도
- LS : O(n^2) 메시지, 진동 있을 수 있음.D
- V : 라우팅 루프 있을 수 있음 (무한대 계수 문제)

견고성
- 잘못된 비용을 알려줬을 때 얼마나 큰 영향을 미치는가?
- LS : 각 라우터는 자신의 테이블만 계산
- DV : 블랙홀링. 네트워크를 통해 오류 전파. 한 노드의 잘못된 계산은 전체로 확산될 수 있다. 취약함.



**OSPF(Open Shortest Path First)를 사용한 인터넷 내부의 AS 내 라우팅**
네트워크? 단순히 상호연결된 라우터의 집합, 라우터끼리 구별 X
동일한 라우팅 알고리즘을 수행하는 동종의 라우터 집합으로 간주 → 지나치게 단순한 관점

- 라우터들을 AS로 조직화하여 확장, 관리 자율성의 문제를 해결
- 동일한 관리 제어하에 있는 라우터의 그룹으로 구성
- AS는 전 세계적으로 고유한 AS번호로 식별ICANN의 지역 등록 기관에 의해 할당됨.
- 다른 말로는 "도메인"


종류
1. intra-AS
  - 같은 AS 내에서의 라우팅
  - 같은 AS 내에 있는 라우터들은 동일한 라우팅 알고리즘 사용
  - 상대의 정보 알 수 있음
  - gateway router : AS의 엣지에서 다른 AS로 라우팅하기 위한 링크를 가짐
  - 내부 목적지 서비스

2. inter-AS
  - 다른 AS 간의 라우팅
  - gateway router는 intra, inter - AS 모두 수행해야함.
  - 외부 목적지 서비스

**intra-AS 라우팅 프로토콜**
RIP : Routing Informaion Protocol
- classic DV
- 더이상 사용 X

EIGRP : Enhanced Interior Gateway Routing Protocol
- DV basedCISCO 전용 라우팅 프로토콜

OSPF : Open Shortest Path First [RFC 2328]
- link-state 라우팅
- IS-IS 프로토콜 : OSPF와 같지만 ISO 표준 프로토콜

**OSFP 개방형 최단 경로 우선 프로토콜**
- AS 내부 라우팅 프로토콜
- open : 퍼블릭하게 사용가능
- link-state 기반 프로토콜
- TCP/UDP 사용하지 않고 IP에 직접적으로 쌓여서 지나감
- 대역폭, 딜레이가 얼만지 고려해서 비용 결정
- 전체 topology 가지고 있어야 함
- 포워딩 테이블 계산을 위해 다익스트라 알고리즘 사용


**보안**
- LS의 견고성
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/e4e7b1dc-15e9-4f3f-ac11-ab44529bd5b4)

- Hierarchical OSPF
  - 두 가지 계층 구조 : local area, backbone
  - backbone : local area의 경계에 있는 것들local area나 backbone 내에서만 브로드캐스트
  - area border routers : 지역 경계, 최종값을 가지고 있음. 정보 주고 받음.


---


**BGP?** Border Gateway Protocolinter
- AS 라우팅 프로토콜서로 다른 인터넷을 붙여주는 접착제
- ⭐️ 인터넷에 있는 수천 개의 ISP들을 연결하는 프로토콜 ⭐️
- 분산형 비동기식 프로토콜TCP 연결이 되어야 동작함.


**BGP의 역할**
- BGP는 목적지 주소가 아닌, CIDR형식으로 표현된 주소의 프리픽스를 향해 전달된다.
- (x, I) 형식의 엔트리
- x : 주소 프리픽스
- I : 라우터 인터페이스의 인터페이스 번호

1. 이웃 AS를 통해 도달 가능한 서브넷 프리픽스 정보를 얻는다. 서브넷의 존재를 알림.
2. 서브넷 주소 프리픽스로의 가장 좋은 경로를 결정한다. 경로 결정 프로시저
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/9d979531-cb5e-42be-b127-41fbb9875dee)

**AS에서의 라우터**
- 게이트웨이 라우터 (ex. 1c)
- AS 경계에 있는 라우터다른 AS들에 있는 여러 개의 라우터와 직접 연결된다.
- 내부 라우터 (ex. 1a, 1b, 1d)
- 자신의 AS 내에 있는 호스트 및 라우터와만 연결된다.


**BGP 연결**
- eBGP (external BGP)
- 2개의 AS를 연결
- 인접 AS로부터 서브넷 도달 가능성 정보 획득
- iBGP (internal BGP)
- 같은 AS 내의 라우터 간 연결
- 모든 AS 내부 라우터에 도달 가능성 정보 전파


---


**최고의 경로 결정**
BGP advertisement 브로드캐스트? 정보 패스로 전달
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/1c644159-6eb0-4912-ba1c-da574d3c2c36)


**BFP advertised route : prefix + attributes**
prefix : 브로드캐스트 중인 목적지


attributes
- AS-PATH : 프리픽스 advertisement가 통과한 AS 목록
- 경로가 여러 개인 경우 정책 기반으로 결정
- NEXT-HOP : 특정 내부 AS 라우터를 다음 홉 AS로 지시

BGP messages
- OPEN : 원격의 BGP peer와 TCP 연결을 맺고 인증 과정을 거침
- UPDATE : 새로운 경로 정보 주고 받음.
- KEEPALIVE : 오랫동안 UPDATE 메세지가 없으면 아직도 살아있다는 정보를 주고 받음.
- NOTIFICATION : 에러 보고


뜨거운 감자 라우팅 Hot potato routing
- 2d가 외부로 라우팅하고 싶을 때 둘 중 어느 경로로 보낼까? ⭐️ 최단 경로 우선 ⭐️ 2a, 2c 중 2a로 보낸다.직접 붙은 두개의 경로 중 짧은 것 선택
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/b829d584-cd80-4b72-bb49-a6359faa6ea1)


---


**SDN 제어평면**
SDN구조의 특징
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/698c0175-a536-4c87-be57-c4ae835dd68d)

플로우 기반 포워딩
- 목적지 주소 기반으로 이루어지는 전통적인 라우터 기반 포워딩과는 대조적인 특성
- SDN의 제어 평면 : 모든 네트워크 스위치의 플로우 테이블 항복들을 계산, 관리, 설치


데이터 평면과 제어 평면의 분리- 매치 플러스 액션 수행
- 제어 평면 : 서버와 스위치들의 플로우 테이블을 결정, 관리하는 소프트웨어
- 네트워크 제어 기능이 데이터 평면 스위치 외부에 존재


SDN 컨트롤러
- 논리적 중앙 집중형
- 협업능력, 확장성, 높은 이용성을 갖도록 함


프로그램이 가능한 네트워크


---


![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/677287fe-fd60-4662-8c89-69cdb9b4828a)


Data-plane 스위치들
- 하드웨어에서 일반화된 데이터 플레인 포워딩을 구현하는 빠르고 간단한 범용 스위치
- 플로우 테이블 계산, 컨트롤러 감독 하에 설치
- 테이블 기반 스위치 제어용 API : OpenFlow
- 컨트롤러와 통신하기 위한 프로토콜 : OpenFlow


SDN 컨트롤러 (네트워크 OS 부분)
- 네트워크의 상태 정보 관리
- southbound API : 스위치 제어
- northbound API : 애플리케이션에 서비스 제공
- 분산 시스템으로 구현 : 논리적으론 중앙 집중형


네트워크 컨트롤 애플리케이션
- 컨트롤의 핵심
- API 이용해서 원하는 것 구현
- unbundled : 제3자 개입 용이


---


***OpenFlow 프로토콜***
컨트롤러가 스위치로 전달하는 메시지
- 스위치의 상태 확인 (features)
- 스위치 설정 셋팅 (configure)
- 플로우 테이블 수정 (modify-state)
- 특정 스위치 포트로 패킷 전공 (packet-out)

스위치가 컨트롤러로 전달하는 메시지
- 컨트롤러로 패킷 전송 (packet-in)
- 스위치의 상태 정보 리포트 (port status)
- 스위치에서 플로우 테이블 삭제 (flow-removed)
- 



</div>
</details>



---



<details>
<summary>6장</summary>
<div markdown="1">       


### 주요용어
- 노드 : 링크 계층(2계층) 프로토콜을 실행하는 장치
- ex) 호스트, 라우터, 스위치, 와이파이 AP
- 링크 : 통신 경로상의 인접한 노드들을 연결하는 통신 채
- 한 링크에서 전송 노드는 데이터그램을 링크 계층 프레임으로 캡슐화해서 링크로 전송
- 서로 다른 링크는 서로 다른 프로토콜 사용 가능

**무선, 유선**
- 프레임 : 2계층 패킷
- 5계층 패킷 : 메시지
- 4계층 패킷 : 세그먼트
- 3계층 패킷 : 데이터그램
- 3계층의 IP, 라우터 : 2계층의 링크 레이어, 스위치 라인
- 3계층이 논리적 주소와 더불어 2계층의 물리적 주소도 알아야 함 - IP 주소 + MAC 주소


---


### 링크 계층이 제공하는 서비스

프레임화
- 네트워크 계층 데이터그램을 링크상으로 전송하기 전에 링크 계층 프레임에 캡슐화
- 프레임 : 네트워크 계층 데이터그램이 들어있는 데이터 필드와 여러 개의 헤더 필드로 구성


링크 접속
- 매체접속제어(MAC) 프로토콜은 링크상으로 프레임을 전송하는 규칙을 명시
- 점대점과 달리 브로드캐스트 링크는 다중 접속 문제 때문에 MAC 프로초콜이 여러 노드로부터의 프레임 전송을 조정


신뢰적 전달
- 일부 트랜스포트 계층 프로토콜(ex. TCP)의 신뢰적 전달 서비스와 마찬가지로 확인응답과 재전송을 통해 가능
- 무선 링크처럼 오류율이 높은 링크에서 주로 사용
- 재전송하는 방식이 아닌 오류가 발생한 링크에서 오류를 정정
- 대다수 유선 링크 계층 프로토콜에서는 제공X : 낮은 비트 오류율을 가진 링크(ex. 광섬유, 동축케이블, 꼬임쌍 선)에서는 불필요한 오버헤드가 될 수 있다.


오류 검출과 정정
- 대부분의 링크 계층 프로토콜에서 제공
- 3,4계층보다 더 복잡
- 하드웨어로 구현
- 오류 정정 : 오류 검출 + 어느 곳에서 오류 발생했는지 정확히 탐색 가능


half-duplex와 full-duplex
- half-duplex : 송수신 가능.
- 동시Xfull-duplex : 송수신 동시 가능.


---


### 링크 계층이 구현하는 위치

NIC(Network Interface Card)에 링크 계층 구현
- 주로 하드웨어 중심
- 부착하게 되면 호스트의 시스템 버스 이용 가능


오류검출 및 정정기술
- EDC : 오류 검출 및 정정 비트
- 데이터에 EDC 추가해서 비트 오류 방지
- 항상은 아니지만 거의 모든 비트 오류 검출 가능


---


### 패리티 검사
```
단일 패리티 비트
짝/홀 : 1의 개수가 짝/홀이어야함
d+1번째에 패리티 비트
2차원 패리티 비트
```

![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/add1bbb8-9826-4a92-a6d5-422bb4c5ee5b)


---


### 다중 접속 링크와 프로토콜
다중 접속 프로토콜

- 컴퓨터 네트워크에서 공유되는 브로드캐스트 채널로 보내는 노드들의 전송을 조정
- 유선 및 무선 접속 네트워크과 위성 네트워크를 포함하는 다양한 네트워크 설정에서 필요
- 여러 개 동시 전송 가능 : 간섭 발생
- 채널을 어떻게 공유할 것인지 결정하는 분산된 알고리즘


이상적인 다중 접속 프로토콜
- 한 노드가 원하면 R의 속도로 전송 가능
- M개의 노드가 원하면 R/M의 속도로 전송 가능
- 분산된 프로토콜. 고장으로 인해 전체 시스템을 정지시킬 수 있는 마스터 노드 부재
- 간단 → 구현 비용 감소


---


### MAC 프로토콜 분류
채널 분할 프로토콜

시간, 주파수 등의 더 작은 조각으로 분할
- 높은 부하 : 효율적, 공정하게 채널 공유
- 낮은 부하 : 비효율적, 채널 엑세스 지연, 활성 노드가 하나만 있어서 1/N 대역폭 할당


랜덤 접속 프로토콜
- 분할X, 충돌 허용
- 충돌로부터 회복
- 높은 부하 : 비효율적, 충돌 오버헤드
- 낮은 부하 : 효율적, 단일 노드가 채널을 최대한으로 활용 가능


순번 프로토콜
- 높은 부하, 낮은 부하 둘 다 효율적


채널 분할 프로토콜
- TDMA : 시분할 다중 접속
- FDMA : 주파수 분할 다중화


---



### 랜덤 접속 프로토콜
- 충돌을 감지하는 방법
- 충돌로부터 회복시키는 방법
- ex) ALOHA, slotted ALOHA, CSMA, CSMA/CD, CSMA/CA


**Pure ALOHA**
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/3945965f-72b2-4958-bdb2-8f00b427911e)

최초의 무선 패킷 통신망
- unslotted Aloha : 더 간단,
- 회선 이용률 비효율적

**Slotted ALOHA**
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/aca11d0f-9210-47fc-a89f-beed0ec5d8d9)


가정
- 모든 프레임은 동일한 사이즈
- 동일한 사이즈의 slot으로 시간 분할
- 슬롯이 시작하는 곳에서만 노드 전송 시작
- 노드 동기화


충돌
- 충돌 발생X : 다음 슬롯에 보낼 새로운 프레임 전송
- 충돌 발생O : 재전송


분산된 형태
- 율적으로 전송 가능, 슬롯의 시작만 맞춤


단점
- 충돌 발생시 슬롯 낭비
- 비어있는 슬롯 존재
- sync가 없는게 좋은데 sync 있음.
- 비효율적


CSMA : Carrier Sense Multiple Access
- 전송하기 전에 확인
- 누가 먼저 쓰고 있으면 holding
- Propagation delay 문제
- 확인해서 없어서 보내기 시작했는데 그 사이에 충돌이 남
- 전체 패킷 전송 시간 낭비
- 비효율적

CSMA/CD : Collsion Detection
- 충돌이 발생했 때 전송을 멈춤
- 회선 빠르게 정리충돌 시 낭비되는 채널 줄어듬.
- 충돌 감지 문제 → 무선에서는 사용X, 충돌 감지해도 못 들음유선에서는 쉽게 사용


성능
- ALOHA보다 성능 good
- CSMA/CD : 이더넷에서 사용
- CSMA/CA : 802.11 무선 랜에서 사용


---


### LANs
**링크 계층 주소체계와 ARP**
ARP? Address Resolution Protocol로 4계층 IP주소를 링크 계층 주소로 변환

**MAC 주소**
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/e77306fc-ed56-45fd-81c4-df5f1470004e)


다른 말로 LAN 주소, 물리 주소라고도 함
- 한 인터페이스에서 물리적으로 연결된 다른 인터페이스로 프레임을 가져오기 위해 '로컬'로 사용됨.
- 동일한 서브넷, IP 주소 지정 방식
- NIC ROM에 기록된 48비트 MAC주소
- 때때로 소프트웨어 설정 가능 ex) 1A-2F-BB-76-09-AD
- LAN의 모든 인터페이스에 MAC주소 + IP주소 할당 필요
- MAC 주소 : 주민등록번호, IP 주소 : 집 주소
- IEEE가 MAC 주소 공간을 관리 → 어떤 어댑터도 동일한 주소를 갖지 않는다.
- 플랫한 주소 : 휴대성
- 한 LAN에서 다른 LAN으로 인터페이스 이동 가능
- IP주소는 휴대성X : 노드가 연결된 IP 서브넷에 따라 상이


ARP
- ARP 테이블모든 호스트, 라우터가 각각 가지고 있음
- IP/MAC 주소를 LAN 노드에 매핑
- TTL : MAC 주소 사용 가능한 시간


랜 내에서의 라우팅 과정
- A에서 B로 데이터그램 전송
- B의 IP주소를 포함한 ARP 쿼리 전송
- MAC 주소는 1로 채워넣음
- 모든 노드가 ARP 쿼리 수신
- B가 MAC 주소에 자신의 맥주소를 담아서 ARP 응답을 전송
- 응답을 받은 A는 자신의 ARP 테이블에 정보를 저장


![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/e8ce6566-8c14-4d21-95b0-14a08fdca643)


---


### 이더넷
- 인터넷 : 글로벌 네트워킹에 관한 것
- 이더넷 : 근거리 네트워킹에 관한 것, 가장 우세한 유선 랜 기술

**물리적 topology**
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/ff0e7c1c-ba18-447c-ab65-cd14f34659c5)


bus
- 90년대 중반 많이 사용
- 모든 노드가 같은 충돌 도메인 내에 있음
- 서로서로 충돌 가능성
- 동축 케이블


switched
- 오늘날 사용
- 2계층 스위치가 센터
- 이더넷 프로토콜 기반으로 동작
- 서로 충돌 X


---


### 스위치

- 2계층 장비
- 들어오는 링크 계층 프레임을 수신해서 출력 링크로 전달하는 것
- transparent : 서브넷의 호스트와 라우터들이 스위치의 존재를 인식하지 못함.
- CSMA/CD MAC 프로토콜 사용
- plug-and-play, 자가 학습 : 따로 설정 필요X


**스위치의 다중 동시 전송충돌**
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/01451f94-8400-4542-afaa-ad19bdaf5298)
- X : full duplex 가능
- 각각의 링크는 자신 만의 충돌 도메인을 가짐
- 하지만 서로 다른 목적지가 아닌 경우 충돌 발생 → 스위치가 각각 시간 차를 두고 조정함.


**스위치와 라우터**
- 둘 다 저장하고 포워드하는 기능


라우터 : 네트워크 계층 장치
- 포워딩 테이블 계산 : 설정된 알고리즘 이용
- IP주소

스위치
- 링크 계층 장치
- 스위칭 테이블 계산 : 자가학습
- MAC 주소

**VLAN**
스위치 계층구조의 단점을 VLAN을 지원하는 스위치를 사용해 해결가능함
스위치 단점
트래픽 격리의 부족

- 그룹 트래픽을 단일 스위치 내로 격리해주지만, 브로드캐스트 트래픽은 여전히 전체 네트워크로 전달되어야만 한다.
- 랜 브로드캐스트 트래픽 제한 필요


스위치의 비효율적인 사용
- 스위치 하나로는 트래픽 격리 불가


사용자 관리
- 한 노드가 다른 그룹으로 이동하는 경우 다른 스위치에 연결하기 위해 물리적 케이블 연결을 변경해야함. →복잡
</div>
</details>


---



<details>
<summary>7장</summary>
<div markdown="1">       

### 무선  
```
wireless: 선을 없이 통신
mobility: 같은장소에서 하지 않더라도 이동하더라도 통신이 됨.
wirless가 더 큰개념
```

**무선 네트워크 요소**
- wireless hosts
- base station(기지국) : 네트워크와 연결된
- wireless link : 기지국과 호스트 사이에 MAC 프로토콜이 필요

infrastructure : 기지국 없이
no infrastructure : 기지국 있이

single hop : 호스트에 바로연결
multiple hops : 건너 건너 까지 연결, 서로서로 통신하면서 기지국이 역할이 되기도 함


**무선 링크 특징**
- 거리에 따라 시그널 강도가 약해짐.
- 주파수 대역이 다르므로 무선 신호 간섭이 심함
- 방해물이 있으면 반사가 되어 늦게오기도 함
- 신호 대비 잡음 비율(SNR): 잡음이 심하면 속도를 줄이거나 높임


**SNR vs BER**
```
(에러에 대한 비트의 비율) → 반비례
강도가 약해질수록 에러 발생 비율도 높아진다 → 잡음이 심해져서
30을 보냈을떄는 에러가 많이 없음
떨어지면 에러가 많아짐 → 속도를 천천히
```
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/fcc64932-a0c4-40e8-a005-38bc4fb1fc7a)


CSMA, CSMA/CD in Wireless
CSMA : 감지를 하는것
CSMA/CD : 충돌이 일어나면 스탑을 하는것

> 둘다 감지를 해야만하는데 감지를 못한다면?

1. A,C 장애물
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/3916c9aa-c14d-48c1-99fa-23a70fd01169)

2. 감지가 약해서 안보낸것처럼 생각함
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/04282dce-9851-4e2c-9a98-8b462449ac15)

---

### Cellular(Cell)
- Cell을 구성하는데 많은 비용이 필요(장비, 토지, 임대료,관리 유지비)
- 도시는 조밀하게, 시골은 느슨하게
- 4각형,원구조보다 < 육각형 구조가 효율적
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/c3b695be-2f99-440e-aa70-3bb4925b978e)

```
mobile switching center은 유선
1. BTS (기지국)
2. BCS (제어국)
3. MSC (교환기)
```


</div>
</details>

---


<details>
<summary>8장</summary>
<div markdown="1">       

### 용어정리

- cryptography
- authentication
- message integrity
- firewalls 와 intrusion detection systems 차이
- 보안의 application, transport, network, link layers

**보안의 4대요소**
1. 기밀성
2. 사용자 인증
3. 일관성/무결성
4. 가용성


**네트워크 공격유형**
스니핑(sniffing) : 해커가 데이터를 몰래 도청
스푸핑(Spoofing) : 네트워크 패킷을 변조하는 공격
세션 하이재킹 : 이미 인증을 받아 세션을 유지하고 있는 연결 상태를 빼앗는 공격
DDoS : DoS 서버에 무의미한 데이터를 무작정 보내 서버를 다운시키는 행위


### Firewall
헤드정보만 읽어서 통과 여부를 판단함 ex) 가방만 검사

![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/a9eddc17-c371-4160-83de-f8559bc8f490)

**방화벽**
```
🔎 네트워크에서 보안을 높이는 가장 1차적인 방법
네트워크 사이를 지나가는 패킷을 정해 놓은 규칙에 의해 차단하거나 보내주는 기능을 가진 장치
Protocol type, 헤더 정보, 주소, 포터 번호를 체크
```

**IDS/IPS**
- 방화벽 뒤에 서버 네트워크 내에서 작동
- 패킷의 내부 정보까지 검토 
- ex) 가방안까지 검사


IDS : 침입한 패킷의 로그 정보만 저장
intrusion detection system
내부 데이터를 검사하고 감지하고 로그만 남김

IPS : 불법 패킷을 아예 차단함
Intrusion Protection System
잘못된 패킷을 발견한 후에 차단
기존의 잘못된 형태를 계속 기억함

**Firewall의 3가지 방식**
1. stateless packet filters
2. stateful packet filters
3. application gateways



</div>
</details>



---

<details>
<summary>과제 1</summary>
<div markdown="1">       

### Computer Network assignment #1

1. 디지털과 아날로그 시그널
- 시그널이란? 추상적인 개념의 정보를 전류나 전압같은 전기적 타형으로 구체적으로 표현한 것으로 정보를 담아 운송하는 수단이다.
- 음성, 오디오, 이미지, 비디오와 같은 것들은 가공하지 않으면 아날로그 형태로 놓여있다.
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/6d17052e-078c-44be-a15f-8af0dc59a3b4)

```
아날로그 시그널은 시간에 대한 연속적인 신호를 말한다. 
반대로 디지털 시그널은 시간에 관한 이상적인 값들로, 아날로그 시그널을 일정 시간 간격마다 샘플링한 값들을 말한다. 
이를 우리는 0,1로 표현하며 digital binary라고 부르기도 한다.

아날로그 시그널은 진폭이 클 수록 소리가 크고, 진폭이 작을 수록 소리가 작다.
아날로그 시그널은 진폭에 정보가 담겨있다. 진폭의 크기 변화에 따라 우리에게 전달되는 정보의 양, 질이 달라진다.
아날로그 신호는  가공을 하는 것이 쉽다는 장점이 있으며 음성이나 비디오와 오디오 전송에 적합하다. 
```
**장점**
<img width="510" alt="image" src="https://github.com/had2-you/had2-you.github.io/assets/72385538/d7d77f91-67aa-4878-86e1-e4610d1b1e20">

**단점**
<img width="521" alt="image" src="https://github.com/had2-you/had2-you.github.io/assets/72385538/6d4345e4-ef06-4649-a6a4-f45de03d91a7">



---


2. Bit
```
앞서 배운 0과 1은 컴퓨터에서 처리하는 정보의 최소 표현단위로 비트라고 한다.
데이터를 표현할 수 없기 때문에 8개의 bit를 묶어 1 byte로 사용하고 있다. 
```

**왜 1 byte는 8 bit 일까?**
그 이유는 미국은 아스키코드 내의 문자만으로 데이터를 표현할 수 있었으며 남는 공간에 특수문자까지 할당할 수 있었기 때문이다.
우리가 알고 있는 아스키코드는 7 bit인데, 왜 8bit 인가?
그 이유는 parity bit 때문이다. 


**parity bit란?**
```
패리티 비트는 정보의 전달 과정에서 오류가 발생했는지 검사하기 위해 추가된 비트이다.
패리티 비트는 짝수와 홀수로 2가지 방법으로 오류를 판단할 수 있다. 

짝수 패리티를 사용한다면 현재 전송되는 데이터의 비트의 1의 개수가 홀수면 1을 맨 뒤로 붙여 짝수로, 짝수라면 0을 맨 뒤에 붙여서 짝수로 1의 개수를 맞춰주는 것이다. 이렇게 8비트로 완성되어 전송이 되는 것이다.
```

---


3. Hz
```
대역폭(bandwidth)란? 네트워크가 단위 시간 내에 전달할 수 있는 최대 크기의 전달용량을 의미한다.
대역폭이 높을수록 많은 데이터가 네트워크에 실려 전달하고 전달 받을 수 있다. 
```

Hz와 bps의 차이?
대역폭 자체와 관련된 것은 용량이며, 단위 시간 내에 전달할 수 있는 데이터의 양으로 bps단위를 사용한다.

![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/ef6dd459-d847-4137-8538-de74377f08a2)
> Hz는 한 번의 사이클을 말하며 bps와 유사한 의미를 가지고 있지만 속도를 나타내는 표현이다.

![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/fbcf660e-a125-4320-92d1-b40eb5ede698)


---


4. 동축케이블 vs 광축케이블
광축케이블? 빛이 전반사 되어서 진행하는 특성을 이용해 만든 케이블

특징
- 신호의 감쇠 정도가 아주 적다.
- UTP랑 달리 수 km ~ 수십 Km 정도의 장거리용으로 사용된다.
- 가격이 비싸고 설치가 힘들다.

통신방식
광케이블 안에 있는 아주 얇은 코어 안에 빛을 투과해 빛의 굴절로 통신이 되는 방식이다. 코어의 굵기가 작을수록 빛의 굴절 각도가 더 작아져서 더 멀리까지 통신이 가능하다.

동축 케이블? 중앙에 절연된 구리선을 전도체가 둘러싸고 있는 케이블
외부적인 간섭이 거의 영향을 미치지 못한다는 장점을 가지고 있으나 수 GHz 대역 이상은 거리에 따라 손실이 크다는 단점이 있다.


</div>
</details>


---

<details>
<summary>과제 2</summary>
<div markdown="1">       

### Computer Network assignment #2


### 1. Web Application Languages
<img width="507" alt="image" src="https://github.com/had2-you/had2-you.github.io/assets/72385538/0dbc990b-49b2-4ad7-81be-7c29f6fe0f4c">


**클라이언트**
클라이언트 기술은 기본적으로 브라우저에 의해 처리되는 요소이다.
화면을 구성하는 HTML5, 스타일을 지정하는 CSS3, 동적으로 사용자 상호작용을 담당하여 처리하는 JavaScript가 있다.



HTML(Hyper Text Markup Language)? 웹 페이지 제작을 위한 가장 기본적인 마크업 언어이다.
제목, 단락, 목록 등 웹페이지의 내용과 구조를 구축하는 역할을 하고 있다.
집 또는 사람으로 비유하면 골격, 뼈에 해당된다.

![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/1da0637c-53fd-45f4-a4a2-eabf76b4ab7c)
네이버의 웹 페이지 구조로 웹의 기반이 되는 틀작업을 위해 사용된다.



CSS(Cascading Style Sheets)? 마크업 언어가 실제로 표시되는 방법을 기술하는 언어이다.
HTML로 구축해 놓은 구조에 꾸미는 작업을 하여 사용자가 보기 좋은 화면을 만들어주는 역할을 한다. 색상, 글꼴, 크기, 레이아웃 등 시각적인 디자인을 위해 사용된다.
집에 비유하자면 인테리어를 하는 것과 같다.



![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/af867315-6bed-497e-8f3a-2c7be069f679)
해당 페이지가 HTML에 CSS가 추가된 웹페이지 이다.

자바 스크립트? 객체지향 스크립트 언어로 사용자가 어떠한 명령을 내렸을 때 반응을 하게끔 해주는 언어이다.
HTML과 CSS를 통해 제작된 웹페이지는 정적인 화면으로 움직이지 않는다. 따라서 동적인 부분을 만들어 주기위해 사용된다.


**서버**
HTML 파일은 파일 내용을 수정하기 전 까지는 내용이 변하지 않는 정적인 구조이기 때문에 동적인 콘텐츠를 생성하기 위해 스크립트 언어가 필요하다. HTML 파일을 생성하고 HTML 내 스크립트 언어를 통해 비즈니스 로직 코드를 삽입한다.

<img width="512" alt="image" src="https://github.com/had2-you/had2-you.github.io/assets/72385538/429548b2-3eef-4b48-8b49-a4db4d425b76">


---


### 2. C/S Architecture P2P


클라이언트 - 서버 구조는 우리가 흔히 아는 구조이다. 항상 켜져있는 호스트를 서버라고 부르고, 서버는 클라이언트라는 많은 호스트의 요청을 받는다.

- 클라이언트 - 서버 구조에서 클라이언트는 서로 직접적인 통신을 하지 않는다. (예) 웹 애플리케이션에서는 2개의 브라우저가 직접적으로 통신하지 않음
- 클라이언트 - 서버 구조의 특징은 서버가 고정 IP 주소를 갖는다.
- 서버는 항상 동작하므로 클라이언트는 서버 주소로 패킷을 보내 항상 서버에 연결할 수 있다.
- 서버가 부족할 경우 많은 수의 호스트를 갖춘 데이터 센터를 운영한다. - 구글 , 빙, 아마존 등 
- 대표적인 예로는 웹, 파일전송, 원격로그인, 전자메일 등이 있다.


P2P(peer-to-peer)구조는 항상 켜져있는 서버에 최소로 의존하거나 아예 의존하지 않는다.
대신 애플리케이션 피어라는 간헐적으로 연결된 호스트 쌍이 서로 직접 통신하도록 한다. 특정 서버를 통하지 않고 피어가 통신하기 때문에 peer-to-peer 구조라고 한다.
- 클라이언트-서버와 P2P 요소들을 결합한 하이브리드 구조를 가질 수 있다.
- P2P구조의 가장 큰 특성중 하나는 자가 확장성이다. P2P 파일 공유에서는 파일을 내려받는 피어를 클라이언트라고 하고 파일을 올리는 피어를 서버라고 한다.
- 따라서 작업의 부하를 다른 피어들에게 분배함으로써 비용에 매우 효율적이다.
- 대표적인 예로 토렌트와 스카이프가 있다.
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/01248bb7-1281-4904-b873-294c77207d26)



---


### 3. 클라우드 컴퓨팅
클라우드 컴퓨팅은 가상화 기술을 활용하여 기존 데이터 센터의 유휴 CPU 사용량을 늘림으로써 추가 H/W구매 없이 인프라 투자 비용을 절감하는데에서 발전하기 시작하였다.

**클라우트 컴퓨팅 특징**
- 주문형 셀프 서비스(On-demand self-service) : 사용자가 서비스 관리자의 개입 없이 원하는 시점에 서비스를 바로 사용할 수 있다.
- Broadband network access(광대역 네트워크 엑세스) : 클라우드 서비스 제공자는 네트워크 기반으로 서비스에 접속할 수 있다.
- Joint management of resources(자원의 공동 관리) : 저장소에 데이터를 모을 수 있고 다양한 계층에 데이터를 제공할 수 있다.
- Fast demand elasticity(빠른 수요 탄력성) : 클라우드 컴퓨팅 서비스를 사용하는 사용자는 자원을 무한대로 확장하거나 필요한 만큼의 수준으로 마음대로 줄일 수 있다.
- Convenient / Easy user environment(편리한/쉬운 사용자 환경) : 불필요한 서버 운영 비용을 내지 않아도 클라우드에서 쓰는 만큼 요금을 지불하기 때문에 경제성이 높다.


클라우드 컴퓨팅의 기술
<img width="504" alt="image" src="https://github.com/had2-you/had2-you.github.io/assets/72385538/3389e404-4e9b-4e9f-aa25-5cb1210d5808">



---


4. IPC
```
IPC란, 프로세스들끼리 서로 데이터를 주고 받는 행위 또는 그에 대한 방법을 말한다.

프로세스는 완전히 독립된 실행 객체인데, 서로 독립되어 있다는 것은 다른 프로세스의 영향을 받지않는다는 장점이 있다. 하지만 독립되어 있는 만큼 별도의 설비가 없이는 서로간의 통신이 어렵다는 문제점이 발생하게 된다.

따라서 커널영역에서 IPC 라는 내부 프로세스간 통신을 제공하게 되고 프로세스는 커널이 제공하는 IPC 설비를 이용해서 프로세스간 통신을 할 수 있게 된다.

여기서 커널이란, 운영체제 자체도 소프트웨어이기 때문에 메모리에 올라가야 사용할 수 있다. 하지만 메모리 공간의 제약으로 인해 운영체제 중 항상 필요한 부분만 메모리에 올려놓고, 그렇지 않은 부분은 필요할 때 메모리에 올려서 사용하게 된다. 이 때 메모리에 상주하는 운영체제의 부분을 커널이라고 한다.
```

**IPC 종류**
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/db83e213-748b-4da1-ae5d-51dca68c7042)

![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/6ead7d32-7f2f-4100-aea8-012582eb48da)



</div>
</details>

