---
title: 'Summary'
layout: post
categories:
  - ComputerNetwork
tags:
  - cs
comments: true
---

<details>
<summary>3주차 내용정리</summary>
<div markdown="1">       

<br>

**분산시스템**
```
🔎 어떤 일을 하나에서 전부 처리하지 않고 분산하여 처리
sysytem? 어떠한 동일한 목적을 이루기위해 여러 개의 구성요소들이 서로 협력하여 해당 일을 효율적으로 처리하는 것
```


### s/w system?
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/985ca25e-779e-472f-9374-d351521b6bbc)
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/f1a7bcf1-9dfc-4531-8d61-ed594b1fae9e)

> P 부분을 client, A와 D를 Server로 나누지만, A와 D를 한번 더 나눌 수도 있음
> 
> 클라이언트 파트는 사용자에게 보여지는 것 뿐만 아니라 처리하는 부분으로 한 번 더 나눌 수 있음(서버의 부담을 줄여줌)
> 
> 사용자 입장에서 컴퓨터 내부에서는 나누어져 있지만 사용자가 의식하면 안됨

<br>

**DNS?**
```
🔎 떨어져 있는 컴퓨터의 ip를 찾아가기 위해 도메인주소와 ip주소를 매칭시켜주는 역할
   → 'www.google.com'이라는 주소를 사용자는 검색했지만 컴퓨터 입장에서는 ip주소를 찾아가야하기 때문
```

찾아가기 위해서는 내 컴퓨터의 ip가 필요, 가정에서의 경우 하나의 고정된 ip를 사용하지만 학교와 같은 경우 필요할 때마다 할당을 해주어야함. → DHCP
어플리케이션 프로그램을 개발하는 입장에서는 라우터와 같은 네트워크 코어 디바이스를 신경쓸 필요가 없음 → 어플리케이션 부분은 운영체제가 담당

<br>

### 분산시스템을 구조화시키는 두가지
1. c/s(client & server) : 클라이언트는 요청, 서버는 응답, cs는 역할이 고정적 서버는 항상 대기를 하고 있어야 함(고정아이피를 가지고 있어야함) 데이터도 많고 집중되기 때문에 데이터 센터에서 운영(최근들어 데이터센터를 운영하는 것이 중요)
→ 운영비 등 비용 소요
→ 각각의 회사가 데이터 센터를 운영하는 것 보다는 서버를 운영하고 도와주는 클라우드 컴퓨터를 이용 클라이언트는 요청만 하기 때문에 고정아이피를 사용할 필요가 없음(동적 아이피)
2. p2p : 좀 더 발달된 형태

```
⭐️ 클라우드 컴퓨팅 ? 많은 컴퓨터가 뭉쳐져 있는 형태 (크게 3가지 종류 나눔)

1. IaaS : 네이버나 구글과 같이 기본적인 메모리 할당해주는 것
2. PaaS : 내 컴퓨터에서 개발하기 위해 프로그램 설치 등 환경을 클라우드가 제공
3. SaaS : 만들어진 것을 이용만 하는 것
```

### P2P architecture

만약 1만명이 이용할 수 있는 서버가 갑자기 10만명이 이용해야한다면 하드웨어 교체 등 비용이 들어가게 됨
→ p2p는 확장성이 좋음(내가 클라이언트도 될 수 있고 서버가 될 수도 있기 때문)

**프로세스와 스레드의 차이**
프로세스? 하드에 있던 어떤 프로그램이 cpu에 올라가서 실행되어지는 상태
쓰레드? 프로세스와 같은 개념이지만 경량화 되어 있음
한 컴퓨터 안에도 클라이언트와 서버가 공존할 수 있음

<br>


![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/84bba63c-c9a6-43cb-8def-ad88b8f03f20)

**소켓**
```
만약 한 컴퓨터 안에 있는 서버와 클라이언트가 소통을 할 때 메세지의 부분까지 설계를 하려고 한다면 번거롭기 때문에 이를 돕는 역할, 운영체제가 제공
서버와 클라이언트에 따라 소켓의 함수차이, 구조가 다름
```

1. bind : 서버는 고정아이피를 가지기 때문에 바인딩하는 함수 사용
2. connect : 클라이언트가 서버에게 커넥트 요청을 보내는 것
3. accept : 수락할 때까지 반복문
4. send/recv : 데이터 주고받는 것

<br>

ip주소 : 32비트, 4자리수 숫자

한 컴퓨터(=주소가 동일하다는 의미) 안에 여러개의 프로세스가 돌아가면 어떻게 주소를 찾나? port number(=process number)를 통해 원하는 곳에 접근 가능
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/3983e7bc-f3bd-4d63-b2c5-07a160214fab)

sequence number : 패킷을 하나만 보내는 것이 아니기때문에 패킷에 순서를 부여
Acknowledge number : 보낸 후 반대쪽에서 응답이 있은 후 다시 보낼 때 받았다는 메세지를 보내는 것
checksum : 에러 유무
요청을 받는 쪽인지 보내는 쪽인지가 맨 앞에 기재됨
신택스에는 정보가 어느 자리에 들어가야 하는지 자리까지 정해져 있음

<br>

**⭐️ syntax vs semantics**
```
프로토콜 안에는 메세지에 syntax, semantics 가 있음
전자 규칙, 문법 후자는 의미
ex) a=b → 자체는 규칙(syntax)이 됨

cs 적 관점 : b를 a에 대입
수학적 관점 : a와 b는 같다
→ 두가지의 의미(semantics)를 가짐
```

data integrity : 파일의 경우 신뢰성이 중요 (no loss)/ 오디오, 비디오와 같은 것들은 손실을 어느정도 반영할 수 있음
timing : 음성의 경우 시간이 중요
throughput : 링크가 가진 대역폭 = R , 패킷의 길이 = L 일 때, L/R = 전송률, 고정적이지 않음, 어느정도의 전송률이 보장되어야 하는가 아닌가? 데이터는 괜찮지만 동영상의 경우 중요함
security : 보안성

### TCP 특징
```
1. 신뢰성있는 전송을 보장, 따라서 보내는 쪽이 안심하고 보내고 받을 수 있음
2.  flow control vs congestion control : A를 클라이언트, B를 서버라고 할 때 B가 데이터를 받은 후 큐(자신의상태)의 상태를 A쪽으로 보낸다.(A가 많은 양의 정보를 보내려고 할 때 라던지..)
                                         → 이렇게 하면 A는 속도를 조절하여 보낸다. → 서버의 문제 congestion 은 통신망 문제
4.  시간, 전송률과 같은 것을 보장하지 못함 (위와 같은 문제에 시간이 들기 때문)
5.  보내기 전에 연결이 확실하게 되었는지 확인(hand-shake)
```
↔ 반대되는 것이 UDP 특징

기본적으로 인터넷은 보안에 취약하기 때문에 다른 프로토콜(SSL)의 도움을 받아야함

**3장**

Web? 거미줄.. 인터넷과 다른 의미, 문서가 연결된 것 hypertext(link) 링크를 타고타고 연결되어 얽히고 웹문서들. 웹페이지는 여러 개의 문서로 연결되어 있다.

웹페이지는 오브젝트(html file, 사진, 오디오 파일 등을 일컫는다)

각각의 위치를 나타낸 것을 URL(오브젝트 들의 주소)이라고 함

### url, urn 차이
```
url은 프로토콜(http://) 포함 urn은 프로토콜 제외, 페이지, 확장자 등을 포함
url + urn = uri
```
sgml → html → xml
xml? 태그<>를 통해 글자의 의미를 부여하고자 함

http를 통해 웹이 어떻게 주고 받는가?

브라우저라는 것을 통해 접근하고 주고받을 때에는 http 전부 프로토콜을 사용

http 하단에는 tcp 프로토콜의 도움을 받음


![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/759dea7d-915c-4ada-804c-db5488be0c07)


클라이언트와 서버가 **3-way handshake**를 함

비상태연결(Stateless)? 클라이언트가 서버에게 한 요청(상태)를 서버가 저장하지 않는 것을 의미
포트번호 = 프로세스번호 한 포트번호에 여러 개의 프로세스가 돌아감
포트번호 배정 누가? 프로세스 누가 관리? → OS

비상태연결 : 기본적으로 상태를 저장하지 않지만 저장하는 방법이 있음 → cookie(쿠키)


### 쿠키? 
```
서버에 들어온 어떤 사람에게 번호를 부여 → 쿠키가 됨
해당 쿠키를 데이터베이스에 저장하고 어떤 아이피를 통해 들어왔는지, 어떤 물건을 구매했는지 등을 저장
서버에서 응답 시 응답메세지에 쿠키번호를 숨겨서 같이 보내줌 하지만 클라이언트는 모름
이후 클라이언트가 페이지를 옮겨 다른 페이지를 볼 때마다 서버에 저장
일주일 후에 들어가도 쿠키가 남아있음
→ CRM 으로 이용..

왜 쿠키 사용? 기본적으로 웹이 비상태이기 때문에 단점을 보완하기 위해
```

### 비지속성(non-persistent)?
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/bfb7e92f-5f83-4cc2-bc4b-35bfe9130a74)

웹페이지의 오브젝트(자원)들이 하나하나 연결과 종료를 반복하며 요청에 대한 응답을 반복 → 시간과 서버자원 낭비

http 1.0 에서 사용

소켓 하나당 오브젝트 한 개 but, 소켓 여러개가 동시에 열릴 수 는 있음

### 지속성(persistent)?

![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/44061b10-abfd-49b1-b816-b18cbaa7e826)
여러 개의 요청, 응답을 서버, 클라이언트간 연결을 유지하면서 처리하는 방식

하나의 소켓으로 전부 연결하며 보내는 것
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/2d766cd5-6f15-4f74-bdf4-3a2a3a41455d)


첫 RTT는 어떠한 동작이 아닌 핸드쉐이크 과정(there’s no receive and send)
다음 RTT에서 동작이 이루어짐 + 막대기가 넓을수록 파일 전송 시간이 더 걸림
∴ 2RTT + 파일 전송 시간 = 응답시간 → 따라서 지속성에서 더 빨리 걸리는 이유는 RTT를 반복하는 시간이 줄어들기 때문



![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/99729e11-a7c0-40a8-abdf-6a196aae4328)

데이터는 있을 수도 없을 수도 상황에 따라 다름
```
1번째 라인 : GET / POST / HEAD(커맨드) : 메시지의 전체적인 의미 // URL // HTTP 버전
2번째 라인 : 도메인 이름
3번째 라인 : 브라우저 이름
```

클라이언트 부분에는 보통 바디가 없음

```
GET : 웹페이지 URL 요청
HEAD : 문서의 내용 없이 타이틀만
POST : 서버에 요청하는 것(예: 네이버 검색시 텍스트 본문을 서버에 요청)
PUT : 파일 단위나 동영상 같은 용량 큰 것을 업로드하기 위한 요청 → 위키피디아, 이러닝 업로드 등
DELETE : 삭제 요청

⚠️ put / delete 는 위험
```
```
301 : 찾고자 하는 주소를 다른 곳에서 보내줌
400 : 이해를 못했을 때(예: 1.0버전만 이해하는 데 1.1로 보냈다던지..)
404 : 서버 주소를 못 찾는 경우
505 : 버전이 안맞는 것
```


웹캐시와 프록시 서버는 다름

웹캐시? 서버쪽에서 쿠키를 관리하는 것이 아닌 클라이언트에서 검색했던 기록을 저장하는 것
프록시 서버? 캐시메모리와 개념이 비슷 → 메모리와 cpu 사이 왔다갔다 하는 시간이 오래걸려서 자주 사용하는 시스템을 캐시에 저장한 후 캐시에서 꺼내서 쓰게 되면서 전체적인 속도를 향상시키기 위한 장치

오리지널 서버는 외부, 프록시 서버는 내부에 존재 → 프록시 서버에서 먼저 검색함 → 속도향상
Conditional GET : 프록시 서버와 오리지널 서버 사이에서 문서가 변형 되었는지, 해당 문서가 맞는지 알 수 없기 때문에 서로 교류하여 문서를 작성한 날자를 대조한 후, 문제가 없다면 문제가 없다는 메시지를 전송
만약 날짜가 다르면 오리지널 문서를 다시 보내줌

</div>
</details>


---

<details>
<summary>3장</summary>
<div markdown="1">       

### 전송 계층의 서비스와 역할

> 프로세스 간 통신: 전송 계층은 송신 프로세스와 수신 프로세스 간의 통신을 담당한다. 이를 위해 포트 번호를 사용하여 프로세스를 식별하고, 데이터를 전송한다.
> 
> 신뢰성: 전송 계층은 데이터의 정확한 전송을 보장하기 위해 오류 검출과 복구 기능을 제공한다. 데이터의 손실, 손상, 중복, 순서 변경 등을 처리하여 신뢰성을 제공한다.
> 
> 흐름 제어: 전송 계층은 수신 측의 버퍼 오버플로우를 방지하기 위해 데이터의 흐름을 조절한다. 수신 측의 처리 속도에 맞춰 송신 측이 데이터를 전송할 수 있도록 합니다.



### TCP의 특징
```
1. 연결형 서비스로 가상 회선 방식을 제공
3-way handshaking 과정을 통해 연결을 설정하고, 4-way handshaking 과정을 통해 연결을 해제한다.

2. 흐름 제어(Flow control)
데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지

3. 혼잡 제어(Congestion control)
네트워크 내의 패킷 수가 과도하게 증가하지 않도록 방지

4. 높은 신뢰성을 보장
신뢰성이 높은 전송을 하기 때문에 UDP보다 속도가 느림

5. 전이중(Full-Duplex), 점대점(Point to Point) 방식
전이중(Full-Duplex) : 전송이 양방향으로 동시에 일어날 수 있다.
점대점(Point to Point) : 각 연결이 정확히 2개의 종단점을 가지고 있다.
```

### UDP의 특징
```
1. 비연결형 서비스로 데이터그램 방식을 제공한다.
데이터의 전송 순서가 바뀔 수 있다.

2. 데이터 수신 여부를 확인하지 않는다.
TCP의 3-way handshaking과 같은 과정 X

3. 신뢰성이 낮다.
흐름 제어(flow control)가 없어서 제대로 전송되었는지, 오류가 없는지 확인할 수 없다.

4. TCP보다 속도가 빠르다.

5. 1:1 , 1:N,N:N 통신이 가능하다.
```




UDP는 신뢰성 낮은 통신 프로토콜이므로 TCP보다 더 단순하다.
서버는 하나의 소켓만으로 통신한다. 
하나의 서버 소켓만 있으면 모든 클라이언트와 자유롭게 통신 가능


dst IP, dst port로 데이터를 전송할 소켓을 구분한다. 
역다중화(demultiplexing) 중에 서버의 IP와 port가 같으면 동일한 서버 소켓으로 전송된다.


TCP는 보다 높은 신뢰성 보장을 위해 UDP보다 복잡하다.
UDP와 달리, 하나의 클라이언트 소켓에 하나의 서버 소켓이 매핑된다. 
ex) 네이버, 티스토리 등의 웹 페이지에 사용자 하나가 접속하면 그 사람을 위한 소켓 하나를 생성한다.

클라이언트 수만큼 소켓이 필요하므로 TCP는 UDP보다 네트워크 자원 소비가 큼


클라이언트가 서버를 찾기 위해 src IP/src Port, dst IP/dst Port를 사용한다. 
역다중화(demultiplexing) 중에 이 중 하나라도 다를 경우 다른 서버 소켓에 전송된다.
UDP와 달리, dst IP, dst Port가 같아도 src IP, src Port가 다르면 서버의 다른 소켓으로 데이터가 전송됨 


### 다중화란?
전송(Transport) 계층에서 다중화(Multiplexing)란 애플리케이션(Application) 계층의 여러 개의 소켓에서 전송되는 데이터를 모아 하나로 모으는 것이다. 이렇게 모아진 메시지 데이터를 세그먼트(Segment)라 한다.

```
여러 개의 소켓에서 전송된 데이터를 다중화하면 세그먼트(Segment)가 된다.

다중화는 전송(Transport) 계층에서만 할 수 있는 것이 아니라, 어느 계층에서든 여러 곳에서 나온 데이터를 하나로 묶을 때에 사용한다.
전송 계층에서의 다중화 데이터는 세그먼트라 부르지만 네트워크 계층에서 다중화한 것은 다른 이름으로 부르는데, 그 경우에는 패킷이라 부른다.
계층마다 다중화했을 때 메시지의 이름이 다르므로 헷갈릴 수 있다.

이렇게 다중화한 메시지엔 헤더(Header)가 붙게 된다.
헤더란 메시지 앞에 붙은 정보를 말한다.
실제 전송하고자 하는 데이터는 헤더 다음에 붙게 된다.

그럼 헤더는 어떤 기능을 하느냐?
헤더는 우편 배달을 할 때 주소 역할을 한다.
데이터가 원하는 곳에 전달되고, 정상적으로 전달될 수 있도록 데이터를 포함하고 있다.
```

### 역다중화란?
```
🔎 전송을 위해 여러 개를 하나로 묶는 것(Multiplexing)이 있다면, 전송이 되었을 때 이를 적절한 소켓에 전달해주는 것도 필요할 것이다.
   이를 역다중화(Demultiplexing)라 한다.
역다중화(demultiplexing)는 전송받은 세그먼트의 데이터를 적절한 소켓에 전달해주는 것이다.
```
mutliplexing이 여러 개를 하나로 묶어주고, demultiplexing은 반대로 하나의 데이터를 적절하게 분배해주는 역할을 한다.
헤더(header): 전송 측의 포트(source port number), 목표 포트(dest port number), 기타(other header fields)
데이터 : 메시지(application data, message)
포트 번호 :
데이터가 상대에게 도달하면 전달받는 측(receiver)은 이를 역다중화(demultiplexing)하여 데이터를 적절한 소켓에 전달한다.
여기서 전달해야 할 소켓을 고르기 위해 포트 번호를 통해 구분한다.
전달하는 쪽의 포트 번호를 source port, 전달받는 쪽의 포트 번호를 dest port로 하여 헤더에 저장한다.


- header 필드의 수: 4개 → 단순한 구조로 되어 있다.
source port 번호: 0~65535 (16 bits이므로 2^16 = 65536)
destination port 번호: 이를 통해 역다중화(demultiplexing)을 함
길이(length) : UDP 세그먼트의 전체 바이트 길이. 본문(message)의 길이와 헤더(header)의 길이를 모두 포함한다.
체크섬(checksum) : 전송 도중에 데이터에 에러가 있는지 아닌지를 판단하기 위한 용도 

checksum에 문제가 발생하면 에러가 발생했음을 확인하고 메세지를 버리게 된다.
이를 통해 udp는 mutliplexing/demutliplexing, 에러 체크 작업을 해주게 된다.


 

RDT(Reliable data transfer) 프로토콜은 TCP에서의 신뢰성을 보장해준다.

1. RDT 1.0: 완벽하게 데이터가 전송되었을 때
하위 계층이 신뢰성 높고(reliable) 완벽하게 데이터를 전송할 때이다.
그렇게 되면 전송(transport) 계층에서 데이터의 신뢰성을 준수할 필요가 없다. 데이터는 하위 계층을 거쳐 전송되므로, 이미 데이터의 신뢰성이 보장되는 셈이다.

2. RDT 2.0: 패킷 에러만 발생할 때
패킷 유실 없이 패킷 에러만 있는 채널을 타고 데이터가 전송될 때이다.
**에러 감지(Error detection)**
- 먼저 에러가 발생했는지를 알아봐야 한다.
- 여기서는 체크섬(checksum) 방법으로 데이터의 무결성을 확인한다. 


**피드백(Feedback)**
- receiver는 데이터를 잘 받았는지 확인하기 위해, 패킷을 받을 때마다 피드백을 주어야 한다.
- 잘 받았다면 ACKs(Acknowledgements), 에러가 발생하면 NAKs(Negative ACKs)을 전송
  
예를 들면, 친구랑 대화할 때 "어, 응"이라고 말하다가, 잘못 들을 경우 "어? 뭐라고?" 등으로 답한다. 이것과 똑같은 원리.


**재전송(Retransmission)**
패킷에 오류가 있으면 다시 전송해준다.
sender가 NAK을 받게 되면 재전송한다.

반대로 ACK를 받게 되면 sender는 제대로 전달되었다고 확인하고, 다음 패킷을 전송한다.


3. RDT 2.1

Sender가 패킷마다 시퀀스 번호(Sequence number)를 붙인다.
피드백(ACK/NAK) 메시지에 오류가 있는지 확인하고, 오류가 있으면 Sender는 현재 패킷을 재전송한다.
Receiver는 복제된 패킷(Duplicate packet)을 버린다.
이외에는 RDT 2.0과 동일

**여기서 시퀀스 넘버는 몇 개까지 셀 수 있어야 할까?**

무한히 많은 수를 셀 수 있다면 좋겠지만 패킷의 헤더는 한계가 있다.
보내는 메시지의 길이가 커질수록 비용도 커지게 된다.
이전에 보낸 것과 같은지 아닌지만 구분할 수 있으면 된다. (복제 패킷을 확인하는 용도)

따라서 1비트(0, 1)만으로 표현할 수 있다.


4. RDT 2.2
여기서 NAK를 없앨 수도 있다.
RDT 2.1에서 무조건 Receiver가 ACK를 보내도록 하는 것이다.
그 대신 마지막으로 받은 정상적인 메시지가 무엇인지를 전송하는 것이다.
예를 들어 마지막으로 시퀀스 넘버가 2인 메시지를 받았다면, ACK 2를 전송한다.
마지막으로 받은 메시지는 시퀀스 넘버(Seq #)를 통해 알려준다.
3번 메시지를 전송했는데 ACK 2가 돌아오거나 ACK 메시지에 에러가 발생했다면, 3번 메시지를 재전송하는 것이다.

5. RDT 3.0: 패킷 유실, 패킷 에러가 발생할 때
대표적인 예시는 카카오톡에서 전송 실패가 뜨는 것이 있겠다.
카카오톡 서버가 불안정할 때나 아예 인터넷에 접속이 안 될 때면 위 사진처럼 발송에 실패하곤 한다.
이 상황이 바로 **패킷 유실(Packet loss)**이다.

이때, 카톡에서는 메시지를 보내고 바로 전달 실패가 되는 것이 아니라 한참이 지나고 나서야 전송이 실패되었다고 알려준다.
어느 정도 시간이 지날 때까지 기다리고 나서도 피드백이 오지 않으면 전송에 실패했다고 판단하는 것이다.

신뢰성 낮은 채널(Unreliable channel)에서는 두 가지 현상이 발생함 
```
- 패킷 에러(Packet error)
    패킷 유실(Packet loss)
    패킷 에러(Packet error)에 대한 대응책 
- 에러 감지(error detection), 피드백(feedback), 재전송(retransmission), 시퀀스 넘버(sequence number)
    패킷 유실(Packet loss)을 위한 대응책 
    타임 아웃(Timeout)
```

파이프라인 프로토콜(Pipelined protocol)
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/aa1b4f3e-bcc2-4f50-9a7f-7cb299e14d29)

한 번에 많은 메시지를 보내고 한 번에 응답을 받는 것이 당연히 더 효율적이다.
신뢰성 있는 파이프라인 프로토콜을 구축하기 위한 방법에는 대표적으로 두 가지가 있다.

- Go-Back-N
- Selective repeat


Go-Back-N
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/361c7115-7829-4289-81ed-c9ad7a66364f)

imeout시 을 재전송한다.
윈도우 내의 모든 패킷

timeout이 발생하면, 윈도우 사이즈(window size)가 N일 때 전송할 대상도 N만큼 다시 돌아오게 된다.

윈도우에 들어 있는 데이터는 버퍼(buffer)에 저장하고 있어야 한다.

윈도우 밖(0, 1): ACK가 왔으므로 전송이 완료됨 → 버퍼에 저장하지 않음
윈도우 내(2, 3, 4, 5): ACK가 오지 않아 제대로 전송되었는지 알 수 없다. → 버퍼에 저장해야 한다.


Go-Back-N의 문제점
Go-Back-N의 문제점은 정상 전송된 패킷이 버려지고 재전송된다는 점이다.
실제로는 윈도우 사이즈가 4 정도로 작지 않다.
원래라면 실패할 경우 그 패킷만 재전송하면 된다.

그러나 Go-Back-N에 따르면 한 패킷만 전송에 실패해도 윈도우 내에 있는 모든 패킷을 재전송해야 한다.


Selective Repeat
Selective Repeat는 패킷이 유실되어 재전송할 때 선별적으로 패킷을 재전송한다.
Go-Back-N처럼 ACK를 누적(cumulative) 방식으로 보내게 되면 어디까지 패킷이 전송되었는지 알 수 없다.

따라서 Selective Repeat에서는 패킷을 받을 때마다 각각 ACK를 전송시켜준다.
예를 들어 7번 패킷을 받으면 ACK 7을 보내는데, 여기서 ACK 7은 7번까지 모두 받았다는 것이 아니라 7번 패킷을 받았다는 뜻이다.
ACK 7을 받게 되면 7번 패킷을 윈도우에서 해제해준다.

그러나 패킷이 순서대로 정렬되어야 하므로 패킷이 유실되었을 때, 그 패킷이 도착할 때까지 다음 순서의 패킷을 임시로 저장해 줄 필요가 있다.

따라서 2번 패킷을 받지 못하고 3, 4번 패킷을 받았을 때 이를 recv 버퍼에 저장해주게 된다.



 
---


### TCP Overview

point-to-point
한 프로세스에는 무조건 한 프로세스가 매핑된다.

sender 하나에 receiver 하나가 연결된다.

TCP는 을 책임진다.
소켓 한 쌍의 통신

reliable, in-order byte

신뢰성이 보장되므로 데이터가 유실되거나 데이터에 에러가 발생하지 않는다.

전송하면 데이터가  전송된다.
순서대로

pipelined

파이프라인 방법을 사용하여, .
한 번에 데이터를 쏟아붓는다

ACK가 돌아올 때까지 기다리지 않고 다음 데이터를 전송한다.

full duplex data

같은 연결에서  데이터가 전송된다.
양방향으로

서버, 클라이언트 모두 서로에게 데이터를 전송할 수 있다. 즉, 모든 서버와 클라이언트는 이다.
sender이자 receiver

sender, receiver buffer

sender는 전송해야 할 데이터를 저장하기 위해 버퍼(buffer)를 사용한다.

receiver는 순서가 뒤바뀐 바이트를 바이트를 받기 위해 버퍼를 사용한다.

모두 sender이자 receiver이므로 모든 디바이스는 와 를 갖는다.
sender 버퍼
receiver 버퍼

flow controlled

sender는 receiver가 만 패킷을 전송할 수 있다.
받을 수 있는 만큼

![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/36737e7d-a37b-4cc4-be6b-f08d4f544632)



포트 번호TCP는 다중화(mutliplexing)와 역다중화(demultiplexing) 과정을 위해 출발지와 도착지의 포트 번호를 요구한다. 포트 번호는 각각 16비트씩 할당되어 총 32비트로 구성된다.

시퀀스 번호(sequence number)는 세그먼트 데이터의 의 바이트 스트림 번호(byte stream number)를 나타낸다. 100바이트를 전송할 때 첫 메시지(세그먼트)는 0~9번 바이트, 두 번째 메시지는 10~29번 바이트까지 보낸다고 하자. 그러면 첫 메시지의 seq #(시퀀스 넘버) = 0이고, 두 번째 메시지의 seq # = 10이 된다.
첫 바이트

acknowledgement numberacknowledgement number는 ACK 번호를 가리킨다. 주의할 점은, TCP에서의 ACK는 이다. 지난 포스팅에서 Go-Back-N에서는 ACK 10이 '10번 세그먼트까지 받았음'을 의미하지만, TCP는 '9번 세그먼트까지 받았고 10번을 받을 차례'를 의미한다. Go-Back-N과 동일하게 ACK가 누적(cumulative)한 방식이지만 그 번호가 갖는 의미가 약간 다른 셈이다.
'다음번에 받을 바이트의 seq #'

checksum체크섬은 에러를 발견하기 위해 사용한다.

Receive windowreceive window는 현재 receiver가 수신할 수 있는 바이트의 수를 말한다. receive 버퍼에 남은 공간이 얼마나 되는지를 가리킨다.


Reliable data transfer

TCP에서 보장하는 rdt(Reliable data transfer) 서비스는 기존 rdt와 비교하여 세 가지 차이점이 있다.

파이프라인 방식으로 세그먼트를 전송

누적 확인 응답(Cumulative acks)

TCP는 재전송을 위해 를 사용함
단일 타이머

또한 TCP는 Go-Back-N과 달리, timeout이 발생하면 해당 세그먼트만 전송하게 된다.



 


흐름제어

만약 수신 측의 recv 버퍼가 꽉 찼을 경우 송신하는 측에서는 데이터를 전송하지 않는다. 이렇게 전송자가 너무 많이, 빨리 전송하여 수신자의 버퍼가 넘치는 일이 없도록 하는 것을 흐름 제어(Flow control)이라 한다.

---

### TCP 3-Way Handshake
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/a9759f9a-5e9c-493d-b39d-0392ff40e486)

TCP 연결 과정(3-way handshake)
TCP에서는 클라이언트와 서버 간에 연결을 구축하기 위해 3-way handshake 방법을 사용한다.

3-way handshake는 이름 그대로 세 번 '악수'하는 과정으로 연결을 구축한다.
그 세 과정은 다음과 같다.

SYN: 클라이언트가 서버에 연결을 요청
클라이언트의 Seq #를 서버에 알려준다.

SYN 메시지를 보낸다는 것은 TCP 커넥션을 열기를 요청하는 것이다.
TCP Header에 있는 를 통해 올릴 수 있다.

syn 신호
SYN/ACK: 서버가 클라이언트에게서 SYN을 받고 SYNACK 세그먼트를 전송

서버의 Seq #를 클라이언트에 알려준다.
이 과정에서 서버가 버퍼를 만든다.

TCP Header에 있는 와 를 이용한다.
syn 신호
ack 신호
ACK: 클라이언트가 SYNACK를 받고 서버에 ACK를 보내줌
ACK 과정에서는 클라이언트가 서버에 실제 데이터를 담아 보낼 수 있다.

왜 SYNACK 과정과 ACK 과정이 필요할까? 
클라이언트는 두 번째 과정 SYNACK를 통해 제대로 메시지가 전송됨을 알 수 있다.
그러나 서버는 ACK 과정이 없으면 메시지가 전송되긴 하지만 정상적으로 전송되었는지 알 수 없기 때문.


TCP 연결 끊기(4-way Handshake)
3-way handshake가 3번 메시지가 오고 가서 3-way라면, TCP 연결 종료는 4번 메시지가 오고 가므로 4-way handshake라 한다.
![image](https://github.com/had2-you/had2-you.github.io/assets/72385538/f63cbc7a-98b9-4cc7-8ce5-40e95eddfc75)

TCP 연결 종료 과정(4-way handshake)
FIN: 클라이언트가 서버에게 FIN을 전송 

클라이언트 장치가 서버에게 FIN을 보내서 연결 종료를 알린다.

ACK: 서버가 클라이언트에게 ACK를 전송 
클라이언트 to 서버 연결 종료 확인 과정
서버는 클라이언트의 연결 중단 요청을 확인하고 피드백으로 ACK를 보내어준다.
FIN: 서버가 클라이언트에게 FIN을 전송 

이번엔 반대로 서버의 연결 중단을 클라이언트에게 고지한다.

클라이언트가 FIN을 수신하면 잠시 동안 timed wait 상태가 되어 연결 종료를 통지받고도 한참 동안 종료되지 않는다.

ACK: 클라이언트가 서버에게 ACK를 전송 
서버 to 클라이언트 연결 종료 확인 과정
서버가 ACK를 받고 나면 TCP 연결이 종료된다.

---

### 혼잡 제어가 하는 일
```
기본적으로 네트워크는 공공의 것(public)으로 소유자가 없다.
누구도 소유하고 있지 않기 때문에 따로 제어하지 않으면 각 기기들은 자유롭게 네트워크를 사용하다가 데이터를 최대한 많이 보내게 된다.

그러나 데이터가 너무 많이 보내지면 문제가 발생한다.
라우터에는 한계가 있기 때문에 데이터 전송량이 많아지면 네트워크의 상태가 안 좋아지고 막히게 된다. 데이터 전송이 원활하지 않게 되는 것이다.

여기서 문제점은 TCP는 '데이터 전송이 잘 안 되면 재전송을 한다'는 점이다.

지금까지 배운 것에 따르면, TCP는 데이터에 오류가 발생하거나 타임아웃이 발생하면 데이터를 재전송한다. 네트워크 상태가 악화될수록 재전송이 잦아져서 더 많은 데이터를 보내고, 상태를 더 악화시키게 된다. TCP는 상태가 안 좋을수록 상태를 더 악화시킨다.


이를 해결하려면 아예 네트워크가 막히지 않게 적당히 조절하는 작업이 필요하다.
네트워크의 소유자는 아무도 없기 때문에 네트워크를 이용하는 각자가 데이터 전송량을 줄이게 된다. 이러한 점에서 TCP는 독립적으로 동작하되 서로 양보해주는 경향을 보인다.
네트워크 상황이 안 좋으면 데이터 전송량을 줄이고, 좋으면 전송량을 늘려준다.
```

</div>
</details>


---



